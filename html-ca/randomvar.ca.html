<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.8.1: http://docutils.sourceforge.net/" />
<title></title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7056 2011-06-17 10:50:48Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document">


<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">rst-ca/randomvar.ca.rst</tt>, line 1)</p>
<p>Malformed table.</p>
<pre class="literal-block">
+----------------------------------+----------------------------------------+-----------------------------------+
| Advanced Bash-Scripting Guide:   |
+==================================+========================================+===================================+
| `Prev &lt;declareref.html&gt;`_        | Chapter 9. Another Look at Variables   | `Next &lt;manipulatingvars.html&gt;`_   |
+----------------------------------+----------------------------------------+-----------------------------------+
</pre>
</div>
<hr class="docutils" />
<div class="section" id="random-generate-random-integer">
<h1>9.3. $RANDOM: generate random integer</h1>
<p><a href="#id1"><span class="problematic" id="id2">**</span></a></p>
<div class="system-message" id="id1">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">rst-ca/randomvar.ca.rst</tt>, line 12); <em><a href="#id2">backlink</a></em></p>
Inline strong start-string without end-string.</div>
<p><em>Anyone who attempts to generate random numbers by deterministic means
is, of course, living in a state of sin.</em></p>
<p><em>--John von Neumann</em></p>
<p><tt class="docutils literal">$RANDOM</tt> is an internal Bash <a class="reference external" href="functions.html#FUNCTIONREF">function</a>
(not a constant) that returns a <em>pseudorandom</em>
<a class="reference external" href="randomvar.html#FTN.AEN5780">[1]</a> integer in the range 0 - 32767. It
should <tt class="docutils literal">not</tt> be used to generate an encryption key.</p>
<p><strong>Example 9-11. Generating random numbers</strong></p>
<pre class="literal-block">
#!/bin/bash

# $RANDOM returns a different random integer at each invocation.
# Nominal range: 0 - 32767 (signed 16-bit integer).

MAXCOUNT=10
count=1

echo
echo &quot;$MAXCOUNT random numbers:&quot;
echo &quot;-----------------&quot;
while [ &quot;$count&quot; -le $MAXCOUNT ]      # Generate 10 ($MAXCOUNT) random integers.
do
  number=$RANDOM
  echo $number
  let &quot;count += 1&quot;  # Increment count.
done
echo &quot;-----------------&quot;

# If you need a random int within a certain range, use the 'modulo' operator.
# This returns the remainder of a division operation.

RANGE=500

echo

number=$RANDOM
let &quot;number %= $RANGE&quot;
#           ^^
echo &quot;Random number less than $RANGE  ---  $number&quot;

echo



#  If you need a random integer greater than a lower bound,
#+ then set up a test to discard all numbers below that.

FLOOR=200

number=0   #initialize
while [ &quot;$number&quot; -le $FLOOR ]
do
  number=$RANDOM
done
echo &quot;Random number greater than $FLOOR ---  $number&quot;
echo

   # Let's examine a simple alternative to the above loop, namely
   #       let &quot;number = $RANDOM + $FLOOR&quot;
   # That would eliminate the while-loop and run faster.
   # But, there might be a problem with that. What is it?



# Combine above two techniques to retrieve random number between two limits.
number=0   #initialize
while [ &quot;$number&quot; -le $FLOOR ]
do
  number=$RANDOM
  let &quot;number %= $RANGE&quot;  # Scales $number down within $RANGE.
done
echo &quot;Random number between $FLOOR and $RANGE ---  $number&quot;
echo



# Generate binary choice, that is, &quot;true&quot; or &quot;false&quot; value.
BINARY=2
T=1
number=$RANDOM

let &quot;number %= $BINARY&quot;
#  Note that    let &quot;number &gt;&gt;= 14&quot;    gives a better random distribution
#+ (right shifts out everything except last binary digit).
if [ &quot;$number&quot; -eq $T ]
then
  echo &quot;TRUE&quot;
else
  echo &quot;FALSE&quot;
fi

echo


# Generate a toss of the dice.
SPOTS=6   # Modulo 6 gives range 0 - 5.
          # Incrementing by 1 gives desired range of 1 - 6.
          # Thanks, Paulo Marcel Coelho Aragao, for the simplification.
die1=0
die2=0
# Would it be better to just set SPOTS=7 and not add 1? Why or why not?

# Tosses each die separately, and so gives correct odds.

    let &quot;die1 = $RANDOM % $SPOTS +1&quot; # Roll first one.
    let &quot;die2 = $RANDOM % $SPOTS +1&quot; # Roll second one.
    #  Which arithmetic operation, above, has greater precedence --
    #+ modulo (%) or addition (+)?


let &quot;throw = $die1 + $die2&quot;
echo &quot;Throw of the dice = $throw&quot;
echo


exit 0
</pre>
<p><strong>Example 9-12. Picking a random card from a deck</strong></p>
<pre class="literal-block">
#!/bin/bash
# pick-card.sh

# This is an example of choosing random elements of an array.


# Pick a card, any card.

Suites=&quot;Clubs
Diamonds
Hearts
Spades&quot;

Denominations=&quot;2
3
4
5
6
7
8
9
10
Jack
Queen
King
Ace&quot;

# Note variables spread over multiple lines.


suite=($Suites)                # Read into array variable.
denomination=($Denominations)

num_suites=${#suite[*]}        # Count how many elements.
num_denominations=${#denomination[*]}

echo -n &quot;${denomination[$((RANDOM%num_denominations))]} of &quot;
echo ${suite[$((RANDOM%num_suites))]}


# $bozo sh pick-cards.sh
# Jack of Clubs


# Thank you, &quot;jipe,&quot; for pointing out this use of $RANDOM.
exit 0
</pre>
<p><strong>Example 9-13. Brownian Motion Simulation</strong></p>
<pre class="literal-block">
#!/bin/bash
# brownian.sh
# Author: Mendel Cooper
# Reldate: 10/26/07
# License: GPL3

#  ----------------------------------------------------------------
#  This script models Brownian motion:
#+ the random wanderings of tiny particles in a fluid,
#+ as they are buffeted by random currents and collisions.
#+ This is colloquially known as the &quot;Drunkard's Walk.&quot;

#  It can also be considered as a stripped-down simulation of a
#+ Galton Board, a slanted board with a pattern of pegs,
#+ down which rolls a succession of marbles, one at a time.
#+ At the bottom is a row of slots or catch basins in which
#+ the marbles come to rest at the end of their journey.
#  Think of it as a kind of bare-bones Pachinko game.
#  As you see by running the script,
#+ most of the marbles cluster around the center slot.
#+ This is consistent with the expected binomial distribution.
#  As a Galton Board simulation, the script
#+ disregards such parameters as
#+ board tilt-angle, rolling friction of the marbles,
#+ angles of impact, and elasticity of the pegs.
#  To what extent does this affect the accuracy of the simulation?
#  ----------------------------------------------------------------

PASSES=500            #  Number of particle interactions / marbles.
ROWS=10               #  Number of &quot;collisions&quot; (or horiz. peg rows).
RANGE=3               #  0 - 2 output range from $RANDOM.
POS=0                 #  Left/right position.
RANDOM=$$             #  Seeds the random number generator from PID
                      #+ of script.

declare -a Slots      # Array holding cumulative results of passes.
NUMSLOTS=21           # Number of slots at bottom of board.


Initialize_Slots () { # Zero out all elements of the array.
for i in $( seq $NUMSLOTS )
do
  Slots[$i]=0
done

echo                  # Blank line at beginning of run.
  }


Show_Slots () {
echo; echo
echo -n &quot; &quot;
for i in $( seq $NUMSLOTS )   # Pretty-print array elements.
do
  printf &quot;%3d&quot; ${Slots[$i]}   # Allot three spaces per result.
done

echo # Row of slots:
echo &quot; |__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|&quot;
echo &quot;                                ||&quot;
echo #  Note that if the count within any particular slot exceeds 99,
     #+ it messes up the display.
     #  Running only(!) 500 passes usually avoids this.
  }


Move () {              # Move one unit right / left, or stay put.
  Move=$RANDOM         # How random is $RANDOM? Well, let's see ...
  let &quot;Move %= RANGE&quot;  # Normalize into range of 0 - 2.
  case &quot;$Move&quot; in
    0 ) ;;                   # Do nothing, i.e., stay in place.
    1 ) ((POS--));;          # Left.
    2 ) ((POS++));;          # Right.
    * ) echo -n &quot;Error &quot;;;   # Anomaly! (Should never occur.)
  esac
  }


Play () {                    # Single pass (inner loop).
i=0
while [ &quot;$i&quot; -lt &quot;$ROWS&quot; ]   # One event per row.
do
  Move
  ((i++));
done

SHIFT=11                     # Why 11, and not 10?
let &quot;POS += $SHIFT&quot;          # Shift &quot;zero position&quot; to center.
(( Slots[$POS]++ ))          # DEBUG: echo $POS

# echo -n &quot;$POS &quot;

  }


Run () {                     # Outer loop.
p=0
while [ &quot;$p&quot; -lt &quot;$PASSES&quot; ]
do
  Play
  (( p++ ))
  POS=0                      # Reset to zero. Why?
done
  }


# --------------
# main ()
Initialize_Slots
Run
Show_Slots
# --------------

exit $?

#  Exercises:
#  ---------
#  1) Show the results in a vertical bar graph, or as an alternative,
#+    a scattergram.
#  2) Alter the script to use /dev/urandom instead of $RANDOM.
#     Will this make the results more random?
#  3) Provide some sort of &quot;animation&quot; or graphic output
#     for each marble played.
</pre>
<p><em>Jipe</em> points out a set of techniques for generating random numbers
within a range.</p>
<pre class="literal-block">
#  Generate random number between 6 and 30.
   rnumber=$((RANDOM%25+6))

#  Generate random number in the same 6 - 30 range,
#+ but the number must be evenly divisible by 3.
   rnumber=$(((RANDOM%30/3+1)*3))

#  Note that this will not work all the time.
#  It fails if $RANDOM%30 returns 0.

#  Frank Wang suggests the following alternative:
   rnumber=$(( RANDOM%27/3*3+6 ))
</pre>
<p><em>Bill Gradwohl</em> came up with an improved formula that works for positive
numbers.</p>
<pre class="literal-block">
rnumber=$(((RANDOM%(max-min+divisibleBy))/divisibleBy*divisibleBy+min))
</pre>
<p>Here Bill presents a versatile function that returns a random number
between two specified values.</p>
<p><strong>Example 9-14. Random between values</strong></p>
<pre class="literal-block">
#!/bin/bash
# random-between.sh
# Random number between two specified values.
# Script by Bill Gradwohl, with minor modifications by the document author.
# Corrections in lines 187 and 189 by Anthony Le Clezio.
# Used with permission.


randomBetween() {
   #  Generates a positive or negative random number
   #+ between $min and $max
   #+ and divisible by $divisibleBy.
   #  Gives a &quot;reasonably random&quot; distribution of return values.
   #
   #  Bill Gradwohl - Oct 1, 2003

   syntax() {
   # Function embedded within function.
      echo
      echo    &quot;Syntax: randomBetween [min] [max] [multiple]&quot;
      echo
      echo -n &quot;Expects up to 3 passed parameters, &quot;
      echo    &quot;but all are completely optional.&quot;
      echo    &quot;min is the minimum value&quot;
      echo    &quot;max is the maximum value&quot;
      echo -n &quot;multiple specifies that the answer must be &quot;
      echo     &quot;a multiple of this value.&quot;
      echo    &quot;    i.e. answer must be evenly divisible by this number.&quot;
      echo
      echo    &quot;If any value is missing, defaults area supplied as: 0 32767 1&quot;
      echo -n &quot;Successful completion returns 0, &quot;
      echo     &quot;unsuccessful completion returns&quot;
      echo    &quot;function syntax and 1.&quot;
      echo -n &quot;The answer is returned in the global variable &quot;
      echo    &quot;randomBetweenAnswer&quot;
      echo -n &quot;Negative values for any passed parameter are &quot;
      echo    &quot;handled correctly.&quot;
   }

   local min=${1:-0}
   local max=${2:-32767}
   local divisibleBy=${3:-1}
   # Default values assigned, in case parameters not passed to function.

   local x
   local spread

   # Let's make sure the divisibleBy value is positive.
   [ ${divisibleBy} -lt 0 ] &amp;&amp; divisibleBy=$((0-divisibleBy))

   # Sanity check.
   if [ $# -gt 3 -o ${divisibleBy} -eq 0 -o  ${min} -eq ${max} ]; then
      syntax
      return 1
   fi

   # See if the min and max are reversed.
   if [ ${min} -gt ${max} ]; then
      # Swap them.
      x=${min}
      min=${max}
      max=${x}
   fi

   #  If min is itself not evenly divisible by $divisibleBy,
   #+ then fix the min to be within range.
   if [ $((min/divisibleBy*divisibleBy)) -ne ${min} ]; then
      if [ ${min} -lt 0 ]; then
         min=$((min/divisibleBy*divisibleBy))
      else
         min=$((((min/divisibleBy)+1)*divisibleBy))
      fi
   fi

   #  If max is itself not evenly divisible by $divisibleBy,
   #+ then fix the max to be within range.
   if [ $((max/divisibleBy*divisibleBy)) -ne ${max} ]; then
      if [ ${max} -lt 0 ]; then
         max=$((((max/divisibleBy)-1)*divisibleBy))
      else
         max=$((max/divisibleBy*divisibleBy))
      fi
   fi

   #  ---------------------------------------------------------------------
   #  Now, to do the real work.

   #  Note that to get a proper distribution for the end points,
   #+ the range of random values has to be allowed to go between
   #+ 0 and abs(max-min)+divisibleBy, not just abs(max-min)+1.

   #  The slight increase will produce the proper distribution for the
   #+ end points.

   #  Changing the formula to use abs(max-min)+1 will still produce
   #+ correct answers, but the randomness of those answers is faulty in
   #+ that the number of times the end points ($min and $max) are returned
   #+ is considerably lower than when the correct formula is used.
   #  ---------------------------------------------------------------------

   spread=$((max-min))
   #  Omair Eshkenazi points out that this test is unnecessary,
   #+ since max and min have already been switched around.
   [ ${spread} -lt 0 ] &amp;&amp; spread=$((0-spread))
   let spread+=divisibleBy
   randomBetweenAnswer=$(((RANDOM%spread)/divisibleBy*divisibleBy+min))

   return 0

   #  However, Paulo Marcel Coelho Aragao points out that
   #+ when $max and $min are not divisible by $divisibleBy,
   #+ the formula fails.
   #
   #  He suggests instead the following formula:
   #    rnumber = $(((RANDOM%(max-min+1)+min)/divisibleBy*divisibleBy))

}

# Let's test the function.
min=-14
max=20
divisibleBy=3


#  Generate an array of expected answers and check to make sure we get
#+ at least one of each answer if we loop long enough.

declare -a answer
minimum=${min}
maximum=${max}
   if [ $((minimum/divisibleBy*divisibleBy)) -ne ${minimum} ]; then
      if [ ${minimum} -lt 0 ]; then
         minimum=$((minimum/divisibleBy*divisibleBy))
      else
         minimum=$((((minimum/divisibleBy)+1)*divisibleBy))
      fi
   fi


   #  If max is itself not evenly divisible by $divisibleBy,
   #+ then fix the max to be within range.

   if [ $((maximum/divisibleBy*divisibleBy)) -ne ${maximum} ]; then
      if [ ${maximum} -lt 0 ]; then
         maximum=$((((maximum/divisibleBy)-1)*divisibleBy))
      else
         maximum=$((maximum/divisibleBy*divisibleBy))
      fi
   fi


#  We need to generate only positive array subscripts,
#+ so we need a displacement that that will guarantee
#+ positive results.

disp=$((0-minimum))
for ((i=${minimum}; i&lt;=${maximum}; i+=divisibleBy)); do
   answer[i+disp]=0
done


# Now loop a large number of times to see what we get.
loopIt=1000   #  The script author suggests 100000,
              #+ but that takes a good long while.

for ((i=0; i&lt;${loopIt}; ++i)); do

   #  Note that we are specifying min and max in reversed order here to
   #+ make the function correct for this case.

   randomBetween ${max} ${min} ${divisibleBy}

   # Report an error if an answer is unexpected.
   [ ${randomBetweenAnswer} -lt ${min} -o ${randomBetweenAnswer} -gt ${max} ] \
   &amp;&amp; echo MIN or MAX error - ${randomBetweenAnswer}!
   [ $((randomBetweenAnswer%${divisibleBy})) -ne 0 ] \
   &amp;&amp; echo DIVISIBLE BY error - ${randomBetweenAnswer}!

   # Store the answer away statistically.
   answer[randomBetweenAnswer+disp]=$((answer[randomBetweenAnswer+disp]+1))
done



# Let's check the results

for ((i=${minimum}; i&lt;=${maximum}; i+=divisibleBy)); do
   [ ${answer[i+disp]} -eq 0 ] \
   &amp;&amp; echo &quot;We never got an answer of $i.&quot; \
   || echo &quot;${i} occurred ${answer[i+disp]} times.&quot;
done


exit 0
</pre>
<p>Just how random is <tt class="docutils literal">$RANDOM</tt>? The best way to test this is to write a
script that tracks the distribution of &quot;random&quot; numbers generated by
<tt class="docutils literal">$RANDOM</tt>. Let's roll a <tt class="docutils literal">$RANDOM</tt> die a few times . . .</p>
<p><strong>Example 9-15. Rolling a single die with RANDOM</strong></p>
<pre class="literal-block">
#!/bin/bash
# How random is RANDOM?

RANDOM=$$       # Reseed the random number generator using script process ID.

PIPS=6          # A die has 6 pips.
MAXTHROWS=600   # Increase this if you have nothing better to do with your time.
throw=0         # Number of times the dice have been cast.

ones=0          #  Must initialize counts to zero,
twos=0          #+ since an uninitialized variable is null, not zero.
threes=0
fours=0
fives=0
sixes=0

print_result ()
{
echo
echo &quot;ones =   $ones&quot;
echo &quot;twos =   $twos&quot;
echo &quot;threes = $threes&quot;
echo &quot;fours =  $fours&quot;
echo &quot;fives =  $fives&quot;
echo &quot;sixes =  $sixes&quot;
echo
}

update_count()
{
case &quot;$1&quot; in
  0) let &quot;ones += 1&quot;;;   # Since die has no &quot;zero&quot;, this corresponds to 1.
  1) let &quot;twos += 1&quot;;;   # And this to 2.
  2) let &quot;threes += 1&quot;;; # Etc.
  3) let &quot;fours += 1&quot;;;
  4) let &quot;fives += 1&quot;;;
  5) let &quot;sixes += 1&quot;;;
esac
}

echo


while [ &quot;$throw&quot; -lt &quot;$MAXTHROWS&quot; ]
do
  let &quot;die1 = RANDOM % $PIPS&quot;
  update_count $die1
  let &quot;throw += 1&quot;
done

print_result

exit 0

#  The scores should distribute fairly evenly, assuming RANDOM is fairly random.
#  With $MAXTHROWS at 600, all should cluster around 100, plus-or-minus 20 or so.
#
#  Keep in mind that RANDOM is a pseudorandom generator,
#+ and not a spectacularly good one at that.

#  Randomness is a deep and complex subject.
#  Sufficiently long &quot;random&quot; sequences may exhibit
#+ chaotic and other &quot;non-random&quot; behavior.

# Exercise (easy):
# ---------------
# Rewrite this script to flip a coin 1000 times.
# Choices are &quot;HEADS&quot; and &quot;TAILS.&quot;
</pre>
<p>As we have seen in the last example, it is best to <em>reseed</em> the
<tt class="docutils literal">RANDOM</tt> generator each time it is invoked. Using the same seed for
<tt class="docutils literal">RANDOM</tt> repeats the same series of numbers.
<a class="reference external" href="randomvar.html#FTN.AEN5820">[2]</a> (This mirrors the behavior of the
<tt class="docutils literal">random()</tt> function in <em>C</em>.)</p>
<p><strong>Example 9-16. Reseeding RANDOM</strong></p>
<pre class="literal-block">
#!/bin/bash
# seeding-random.sh: Seeding the RANDOM variable.

MAXCOUNT=25       # How many numbers to generate.

random_numbers ()
{
count=0
while [ &quot;$count&quot; -lt &quot;$MAXCOUNT&quot; ]
do
  number=$RANDOM
  echo -n &quot;$number &quot;
  let &quot;count += 1&quot;
done
}

echo; echo

RANDOM=1          # Setting RANDOM seeds the random number generator.
random_numbers

echo; echo

RANDOM=1          # Same seed for RANDOM...
random_numbers    # ...reproduces the exact same number series.
                  #
                  # When is it useful to duplicate a &quot;random&quot; number series?

echo; echo

RANDOM=2          # Trying again, but with a different seed...
random_numbers    # gives a different number series.

echo; echo

# RANDOM=$$  seeds RANDOM from process id of script.
# It is also possible to seed RANDOM from 'time' or 'date' commands.

# Getting fancy...
SEED=$(head -1 /dev/urandom | od -N 1 | awk '{ print $2 }')
#  Pseudo-random output fetched
#+ from /dev/urandom (system pseudo-random device-file),
#+ then converted to line of printable (octal) numbers by &quot;od&quot;,
#+ finally &quot;awk&quot; retrieves just one number for SEED.
RANDOM=$SEED
random_numbers

echo; echo

exit 0
</pre>
<div class="figure align-center">
<img alt="Note" src="http://tldp.org/LDP/abs/images/note.gif" />
<p class="caption">Note</p>
</div>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">rst-ca/randomvar.ca.rst</tt>, line 685)</p>
Explicit markup ends without a blank line; unexpected unindent.</div>
<p>The <tt class="docutils literal">/dev/urandom</tt> pseudo-device file provides a method of generating
much more &quot;random&quot; pseudorandom numbers than the <tt class="docutils literal">$RANDOM</tt> variable.
<tt class="docutils literal">dd <span class="pre">if=/dev/urandom</span> of=targetfile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bs=1 count=XX</tt> creates a file
of well-scattered pseudorandom numbers. However, assigning these numbers
to a variable in a script requires a workaround, such as filtering
through <a class="reference external" href="extmisc.html#ODREF">od</a> (as in above example, <a class="reference external" href="textproc.html#RND">Example
16-14</a>, and <a class="reference external" href="contributed-scripts.html#INSERTIONSORT">Example
A-36</a>), or even piping to
<a class="reference external" href="filearchiv.html#MD5SUMREF">md5sum</a> (see <a class="reference external" href="colorizing.html#HORSERACE">Example
36-14</a>).</p>
<p>There are also other ways to generate pseudorandom numbers in a script.
<strong>Awk</strong> provides a convenient means of doing this.</p>
<p><strong>Example 9-17. Pseudorandom numbers, using `awk &lt;awk.html#AWKREF&gt;`_</strong></p>
<pre class="literal-block">
#!/bin/bash
# random2.sh: Returns a pseudorandom number in the range 0 - 1.
# Uses the awk rand() function.

AWKSCRIPT=' { srand(); print rand() } '
#            Command(s) / parameters passed to awk
# Note that srand() reseeds awk's random number generator.


echo -n &quot;Random number between 0 and 1 = &quot;

echo | awk &quot;$AWKSCRIPT&quot;
# What happens if you leave out the 'echo'?

exit 0


# Exercises:
# ---------

# 1) Using a loop construct, print out 10 different random numbers.
#      (Hint: you must reseed the &quot;srand()&quot; function with a different seed
#+     in each pass through the loop. What happens if you fail to do this?)

# 2) Using an integer multiplier as a scaling factor, generate random numbers
#+   in the range between 10 and 100.

# 3) Same as exercise #2, above, but generate random integers this time.
</pre>
<p>The <a class="reference external" href="timedate.html#DATEREF">date</a> command also lends itself to
<a class="reference external" href="timedate.html#DATERANDREF">generating pseudorandom integer
sequences</a>.</p>
<div class="section" id="notes">
<h2>Notes</h2>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">rst-ca/randomvar.ca.rst</tt>, line 10); <em><a href="#id5">backlink</a></em></p>
Duplicate explicit target name: &quot;[1]&quot;.</div>
<p><a class="reference external" href="randomvar.html#AEN5780">[1]</a></p>
<p>True &quot;randomness,&quot; insofar as it exists at all, can only be found in
certain incompletely understood natural phenomena, such as radioactive
decay. Computers only <em>simulate</em> randomness, and computer-generated
sequences of &quot;random&quot; numbers are therefore referred to as
<em>pseudorandom</em>.</p>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">rst-ca/randomvar.ca.rst</tt>, line 10); <em><a href="#id6">backlink</a></em></p>
Duplicate explicit target name: &quot;[2]&quot;.</div>
<p><a class="reference external" href="randomvar.html#AEN5820">[2]</a></p>
<p>The <em>seed</em> of a computer-generated pseudorandom number series can be
considered an identification label. For example, think of the
pseudorandom series with a seed of <em>23</em> as <tt class="docutils literal">Series&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #23</tt>.</p>
<p>A property of a pseurandom number series is the length of the cycle
before it starts repeating itself. A good pseurandom generator will
produce series with very long cycles.</p>
<hr class="docutils" />
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="25%" />
<col width="32%" />
</colgroup>
<tbody valign="top">
<tr><td><a class="reference external" href="declareref.html">Prev</a></td>
<td><a class="reference external" href="index.html">Home</a></td>
<td><a class="reference external" href="manipulatingvars.html">Next</a></td>
</tr>
<tr><td>Typing variables: <strong>declare</strong> or <strong>typeset</strong></td>
<td><a class="reference external" href="variables2.html">Up</a></td>
<td>Manipulating Variables</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</body>
</html>
