<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.8.1: http://docutils.sourceforge.net/" />
<title></title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7056 2011-06-17 10:50:48Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document">


<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">rst-ca/colorizing.ca.rst</tt>, line 1)</p>
<p>Malformed table.</p>
<pre class="literal-block">
+----------------------------------+--------------------------+--------------------------------+
| Advanced Bash-Scripting Guide:   |
+==================================+==========================+================================+
| `Prev &lt;recursionsct.html&gt;`_      | Chapter 36. Miscellany   | `Next &lt;optimizations.html&gt;`_   |
+----------------------------------+--------------------------+--------------------------------+
</pre>
</div>
<hr class="docutils" />
<div class="section" id="colorizing-scripts">
<h1>36.5. &quot;Colorizing&quot; Scripts</h1>
<p>The ANSI <a class="reference external" href="colorizing.html#FTN.AEN20101">[1]</a> escape sequences set
screen attributes, such as bold text, and color of foreground and
background. <a class="reference external" href="dosbatch.html#DOSBATCH1">DOS batch files</a> commonly used
ANSI escape codes for <em>color</em> output, and so can Bash scripts.</p>
<p><strong>Example 36-11. A &quot;colorized&quot; address database</strong></p>
<pre class="literal-block">
#!/bin/bash
# ex30a.sh: &quot;Colorized&quot; version of ex30.sh.
#            Crude address database


clear                                   # Clear the screen.

echo -n &quot;          &quot;
echo -e '\E[37;44m'&quot;\033[1mContact List\033[0m&quot;
                                        # White on blue background
echo; echo
echo -e &quot;\033[1mChoose one of the following persons:\033[0m&quot;
                                        # Bold
tput sgr0                               # Reset attributes.
echo &quot;(Enter only the first letter of name.)&quot;
echo
echo -en '\E[47;34m'&quot;\033[1mE\033[0m&quot;   # Blue
tput sgr0                               # Reset colors to &quot;normal.&quot;
echo &quot;vans, Roland&quot;                     # &quot;[E]vans, Roland&quot;
echo -en '\E[47;35m'&quot;\033[1mJ\033[0m&quot;   # Magenta
tput sgr0
echo &quot;ones, Mildred&quot;
echo -en '\E[47;32m'&quot;\033[1mS\033[0m&quot;   # Green
tput sgr0
echo &quot;mith, Julie&quot;
echo -en '\E[47;31m'&quot;\033[1mZ\033[0m&quot;   # Red
tput sgr0
echo &quot;ane, Morris&quot;
echo

read person

case &quot;$person&quot; in
# Note variable is quoted.

  &quot;E&quot; | &quot;e&quot; )
  # Accept upper or lowercase input.
  echo
  echo &quot;Roland Evans&quot;
  echo &quot;4321 Flash Dr.&quot;
  echo &quot;Hardscrabble, CO 80753&quot;
  echo &quot;(303) 734-9874&quot;
  echo &quot;(303) 734-9892 fax&quot;
  echo &quot;revans&#64;zzy.net&quot;
  echo &quot;Business partner &amp; old friend&quot;
  ;;

  &quot;J&quot; | &quot;j&quot; )
  echo
  echo &quot;Mildred Jones&quot;
  echo &quot;249 E. 7th St., Apt. 19&quot;
  echo &quot;New York, NY 10009&quot;
  echo &quot;(212) 533-2814&quot;
  echo &quot;(212) 533-9972 fax&quot;
  echo &quot;milliej&#64;loisaida.com&quot;
  echo &quot;Girlfriend&quot;
  echo &quot;Birthday: Feb. 11&quot;
  ;;

# Add info for Smith &amp; Zane later.

          * )
   # Default option.
   # Empty input (hitting RETURN) fits here, too.
   echo
   echo &quot;Not yet in database.&quot;
  ;;

esac

tput sgr0                               # Reset colors to &quot;normal.&quot;

echo

exit 0
</pre>
<p><strong>Example 36-12. Drawing a box</strong></p>
<pre class="literal-block">
#!/bin/bash
# Draw-box.sh: Drawing a box using ASCII characters.

# Script by Stefano Palmeri, with minor editing by document author.
# Minor edits suggested by Jim Angstadt.
# Used in the ABS Guide with permission.


######################################################################
###  draw_box function doc  ###

#  The &quot;draw_box&quot; function lets the user
#+ draw a box in a terminal.
#
#  Usage: draw_box ROW COLUMN HEIGHT WIDTH [COLOR]
#  ROW and COLUMN represent the position
#+ of the upper left angle of the box you're going to draw.
#  ROW and COLUMN must be greater than 0
#+ and less than current terminal dimension.
#  HEIGHT is the number of rows of the box, and must be &gt; 0.
#  HEIGHT + ROW must be &lt;= than current terminal height.
#  WIDTH is the number of columns of the box and must be &gt; 0.
#  WIDTH + COLUMN must be &lt;= than current terminal width.
#
# E.g.: If your terminal dimension is 20x80,
#  draw_box 2 3 10 45 is good
#  draw_box 2 3 19 45 has bad HEIGHT value (19+2 &gt; 20)
#  draw_box 2 3 18 78 has bad WIDTH value (78+3 &gt; 80)
#
#  COLOR is the color of the box frame.
#  This is the 5th argument and is optional.
#  0=black 1=red 2=green 3=tan 4=blue 5=purple 6=cyan 7=white.
#  If you pass the function bad arguments,
#+ it will just exit with code 65,
#+ and no messages will be printed on stderr.
#
#  Clear the terminal before you start to draw a box.
#  The clear command is not contained within the function.
#  This allows the user to draw multiple boxes, even overlapping ones.

###  end of draw_box function doc  ###
######################################################################

draw_box(){

#=============#
HORZ=&quot;-&quot;
VERT=&quot;|&quot;
CORNER_CHAR=&quot;+&quot;

MINARGS=4
E_BADARGS=65
#=============#


if [ $# -lt &quot;$MINARGS&quot; ]; then          # If args are less than 4, exit.
    exit $E_BADARGS
fi

# Looking for non digit chars in arguments.
# Probably it could be done better (exercise for the reader?).
if echo $&#64; | tr -d [:blank:] | tr -d [:digit:] | grep . &amp;&gt; /dev/null; then
   exit $E_BADARGS
fi

BOX_HEIGHT=`expr $3 - 1`   #  -1 correction needed because angle char &quot;+&quot;
BOX_WIDTH=`expr $4 - 1`    #+ is a part of both box height and width.
T_ROWS=`tput lines`        #  Define current terminal dimension
T_COLS=`tput cols`         #+ in rows and columns.

if [ $1 -lt 1 ] || [ $1 -gt $T_ROWS ]; then    #  Start checking if arguments
   exit $E_BADARGS                             #+ are correct.
fi
if [ $2 -lt 1 ] || [ $2 -gt $T_COLS ]; then
   exit $E_BADARGS
fi
if [ `expr $1 + $BOX_HEIGHT + 1` -gt $T_ROWS ]; then
   exit $E_BADARGS
fi
if [ `expr $2 + $BOX_WIDTH + 1` -gt $T_COLS ]; then
   exit $E_BADARGS
fi
if [ $3 -lt 1 ] || [ $4 -lt 1 ]; then
   exit $E_BADARGS
fi                                 # End checking arguments.

plot_char(){                       # Function within a function.
   echo -e &quot;\E[${1};${2}H&quot;$3
}

echo -ne &quot;\E[3${5}m&quot;               # Set box frame color, if defined.

# start drawing the box

count=1                                         #  Draw vertical lines using
for (( r=$1; count&lt;=$BOX_HEIGHT; r++)); do      #+ plot_char function.
  plot_char $r $2 $VERT
  let count=count+1
done

count=1
c=`expr $2 + $BOX_WIDTH`
for (( r=$1; count&lt;=$BOX_HEIGHT; r++)); do
  plot_char $r $c $VERT
  let count=count+1
done

count=1                                        #  Draw horizontal lines using
for (( c=$2; count&lt;=$BOX_WIDTH; c++)); do      #+ plot_char function.
  plot_char $1 $c $HORZ
  let count=count+1
done

count=1
r=`expr $1 + $BOX_HEIGHT`
for (( c=$2; count&lt;=$BOX_WIDTH; c++)); do
  plot_char $r $c $HORZ
  let count=count+1
done

plot_char $1 $2 $CORNER_CHAR                   # Draw box angles.
plot_char $1 `expr $2 + $BOX_WIDTH` $CORNER_CHAR
plot_char `expr $1 + $BOX_HEIGHT` $2 $CORNER_CHAR
plot_char `expr $1 + $BOX_HEIGHT` `expr $2 + $BOX_WIDTH` $CORNER_CHAR

echo -ne &quot;\E[0m&quot;             #  Restore old colors.

P_ROWS=`expr $T_ROWS - 1`    #  Put the prompt at bottom of the terminal.

echo -e &quot;\E[${P_ROWS};1H&quot;
}


# Now, let's try drawing a box.
clear                       # Clear the terminal.
R=2      # Row
C=3      # Column
H=10     # Height
W=45     # Width
col=1    # Color (red)
draw_box $R $C $H $W $col   # Draw the box.

exit 0

# Exercise:
# --------
# Add the option of printing text within the drawn box.
</pre>
<p>The simplest, and perhaps most useful ANSI escape sequence is bold text,
<strong>\033[1m ... \033[0m</strong>. The \033 represents an
<a class="reference external" href="escapingsection.html#ESCP">escape</a>, the &quot;[1&quot; turns on the bold
attribute, while the &quot;[0&quot; switches it off. The &quot;m&quot; terminates each term
of the escape sequence.</p>
<pre class="literal-block">
bash$ echo -e &quot;\033[1mThis is bold text.\033[0m&quot;
</pre>
<p>A similar escape sequence switches on the underline attribute (on an
<em>rxvt</em> and an <em>aterm</em>).</p>
<pre class="literal-block">
bash$ echo -e &quot;\033[4mThis is underlined text.\033[0m&quot;
</pre>
<div class="figure align-center">
<img alt="Note" src="http://tldp.org/LDP/abs/images/note.gif" />
<p class="caption">Note</p>
</div>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">rst-ca/colorizing.ca.rst</tt>, line 273)</p>
Explicit markup ends without a blank line; unexpected unindent.</div>
<p>With an <strong>echo</strong>, the <tt class="docutils literal"><span class="pre">-e</span></tt> option enables the escape sequences.</p>
<p>Other escape sequences change the text and/or background color.</p>
<pre class="literal-block">
bash$ echo -e '\E[34;47mThis prints in blue.'; tput sgr0


bash$ echo -e '\E[33;44m'&quot;yellow text on blue background&quot;; tput sgr0


bash$ echo -e '\E[1;33;44m'&quot;BOLD yellow text on blue background&quot;; tput sgr0
</pre>
<div class="figure align-center">
<img alt="Note" src="http://tldp.org/LDP/abs/images/note.gif" />
<p class="caption">Note</p>
</div>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">rst-ca/colorizing.ca.rst</tt>, line 293)</p>
Explicit markup ends without a blank line; unexpected unindent.</div>
<p>It's usually advisable to set the <em>bold</em> attribute for light-colored
foreground text.</p>
<p>The <strong>tput sgr0</strong> restores the terminal settings to normal. Omitting
this lets all subsequent output from that particular terminal remain
blue.</p>
<div class="figure align-center">
<img alt="Note" src="http://tldp.org/LDP/abs/images/note.gif" />
<p class="caption">Note</p>
</div>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">rst-ca/colorizing.ca.rst</tt>, line 305)</p>
Explicit markup ends without a blank line; unexpected unindent.</div>
<p>Since <strong>tput sgr0</strong> fails to restore terminal settings under certain
circumstances, <strong>echo -ne \E[0m</strong> may be a better choice.</p>
<p>Use the following template for writing colored text on a colored
background.</p>
<p><tt class="docutils literal">echo <span class="pre">-e</span> '\E[COLOR1;COLOR2mSome text goes here.'</tt></p>
<p>The &quot;\E[&quot; begins the escape sequence. The semicolon-separated numbers
&quot;COLOR1&quot; and &quot;COLOR2&quot; specify a foreground and a background color,
according to the table below. (The order of the numbers does not matter,
since the foreground and background numbers fall in non-overlapping
ranges.) The &quot;m&quot; terminates the escape sequence, and the text begins
immediately after that.</p>
<p>Note also that <a class="reference external" href="varsubn.html#SNGLQUO">single quotes</a> enclose the
remainder of the command sequence following the <strong>echo -e</strong>.</p>
<p>The numbers in the following table work for an <em>rxvt</em> terminal. Results
may vary for other terminal emulators.</p>
<p><strong>Table 36-1. Numbers representing colors in Escape Sequences</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Color</th>
<th class="head">Foreground</th>
<th class="head">Background</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">black</tt></td>
<td>30</td>
<td>40</td>
</tr>
<tr><td><tt class="docutils literal">red</tt></td>
<td>31</td>
<td>41</td>
</tr>
<tr><td><tt class="docutils literal">green</tt></td>
<td>32</td>
<td>42</td>
</tr>
<tr><td><tt class="docutils literal">yellow</tt></td>
<td>33</td>
<td>43</td>
</tr>
<tr><td><tt class="docutils literal">blue</tt></td>
<td>34</td>
<td>44</td>
</tr>
<tr><td><tt class="docutils literal">magenta</tt></td>
<td>35</td>
<td>45</td>
</tr>
<tr><td><tt class="docutils literal">cyan</tt></td>
<td>36</td>
<td>46</td>
</tr>
<tr><td><tt class="docutils literal">white</tt></td>
<td>37</td>
<td>47</td>
</tr>
</tbody>
</table>
<p><strong>Example 36-13. Echoing colored text</strong></p>
<pre class="literal-block">
#!/bin/bash
# color-echo.sh: Echoing text messages in color.

# Modify this script for your own purposes.
# It's easier than hand-coding color.

black='\E[30;47m'
red='\E[31;47m'
green='\E[32;47m'
yellow='\E[33;47m'
blue='\E[34;47m'
magenta='\E[35;47m'
cyan='\E[36;47m'
white='\E[37;47m'


alias Reset=&quot;tput sgr0&quot;      #  Reset text attributes to normal
                             #+ without clearing screen.


cecho ()                     # Color-echo.
                             # Argument $1 = message
                             # Argument $2 = color
{
local default_msg=&quot;No message passed.&quot;
                             # Doesn't really need to be a local variable.

message=${1:-$default_msg}   # Defaults to default message.
color=${2:-$black}           # Defaults to black, if not specified.

  echo -e &quot;$color&quot;
  echo &quot;$message&quot;
  Reset                      # Reset to normal.

  return
}


# Now, let's try it out.
# ----------------------------------------------------
cecho &quot;Feeling blue...&quot; $blue
cecho &quot;Magenta looks more like purple.&quot; $magenta
cecho &quot;Green with envy.&quot; $green
cecho &quot;Seeing red?&quot; $red
cecho &quot;Cyan, more familiarly known as aqua.&quot; $cyan
cecho &quot;No color passed (defaults to black).&quot;
       # Missing $color argument.
cecho &quot;\&quot;Empty\&quot; color passed (defaults to black).&quot; &quot;&quot;
       # Empty $color argument.
cecho
       # Missing $message and $color arguments.
cecho &quot;&quot; &quot;&quot;
       # Empty $message and $color arguments.
# ----------------------------------------------------

echo

exit 0

# Exercises:
# ---------
# 1) Add the &quot;bold&quot; attribute to the 'cecho ()' function.
# 2) Add options for colored backgrounds.
</pre>
<p><strong>Example 36-14. A &quot;horserace&quot; game</strong></p>
<pre class="literal-block">
#!/bin/bash
# horserace.sh: Very simple horserace simulation.
# Author: Stefano Palmeri
# Used with permission.

################################################################
#  Goals of the script:
#  playing with escape sequences and terminal colors.
#
#  Exercise:
#  Edit the script to make it run less randomly,
#+ set up a fake betting shop . . .
#  Um . . . um . . . it's starting to remind me of a movie . . .
#
#  The script gives each horse a random handicap.
#  The odds are calculated upon horse handicap
#+ and are expressed in European(?) style.
#  E.g., odds=3.75 means that if you bet $1 and win,
#+ you receive $3.75.
#
#  The script has been tested with a GNU/Linux OS,
#+ using xterm and rxvt, and konsole.
#  On a machine with an AMD 900 MHz processor,
#+ the average race time is 75 seconds.
#  On faster computers the race time would be lower.
#  So, if you want more suspense, reset the USLEEP_ARG variable.
#
#  Script by Stefano Palmeri.
################################################################

E_RUNERR=65

# Check if md5sum and bc are installed.
if ! which bc &amp;&gt; /dev/null; then
   echo bc is not installed.
   echo &quot;Can\'t run . . . &quot;
   exit $E_RUNERR
fi
if ! which md5sum &amp;&gt; /dev/null; then
   echo md5sum is not installed.
   echo &quot;Can\'t run . . . &quot;
   exit $E_RUNERR
fi

#  Set the following variable to slow down script execution.
#  It will be passed as the argument for usleep (man usleep)
#+ and is expressed in microseconds (500000 = half a second).
USLEEP_ARG=0

#  Clean up the temp directory, restore terminal cursor and
#+ terminal colors -- if script interrupted by Ctl-C.
trap 'echo -en &quot;\E[?25h&quot;; echo -en &quot;\E[0m&quot;; stty echo;\
tput cup 20 0; rm -fr  $HORSE_RACE_TMP_DIR'  TERM EXIT
#  See the chapter on debugging for an explanation of 'trap.'

# Set a unique (paranoid) name for the temp directory the script needs.
HORSE_RACE_TMP_DIR=$HOME/.horserace-`date +%s`-`head -c10 /dev/urandom \
| md5sum | head -c30`

# Create the temp directory and move right in.
mkdir $HORSE_RACE_TMP_DIR
cd $HORSE_RACE_TMP_DIR


#  This function moves the cursor to line $1 column $2 and then prints $3.
#  E.g.: &quot;move_and_echo 5 10 linux&quot; is equivalent to
#+ &quot;tput cup 4 9; echo linux&quot;, but with one command instead of two.
#  Note: &quot;tput cup&quot; defines 0 0 the upper left angle of the terminal,
#+ echo defines 1 1 the upper left angle of the terminal.
move_and_echo() {
          echo -ne &quot;\E[${1};${2}H&quot;&quot;$3&quot;
}

# Function to generate a pseudo-random number between 1 and 9.
random_1_9 ()
{
    head -c10 /dev/urandom | md5sum | tr -d [a-z] | tr -d 0 | cut -c1
}

#  Two functions that simulate &quot;movement,&quot; when drawing the horses.
draw_horse_one() {
               echo -n &quot; &quot;//$MOVE_HORSE//
}
draw_horse_two(){
              echo -n &quot; &quot;\\\\$MOVE_HORSE\\\\
}


# Define current terminal dimension.
N_COLS=`tput cols`
N_LINES=`tput lines`

# Need at least a 20-LINES X 80-COLUMNS terminal. Check it.
if [ $N_COLS -lt 80 ] || [ $N_LINES -lt 20 ]; then
   echo &quot;`basename $0` needs a 80-cols X 20-lines terminal.&quot;
   echo &quot;Your terminal is ${N_COLS}-cols X ${N_LINES}-lines.&quot;
   exit $E_RUNERR
fi


# Start drawing the race field.

# Need a string of 80 chars. See below.
BLANK80=`seq -s &quot;&quot; 100 | head -c80`

clear

# Set foreground and background colors to white.
echo -ne '\E[37;47m'

# Move the cursor on the upper left angle of the terminal.
tput cup 0 0

# Draw six white lines.
for n in `seq 5`; do
      echo $BLANK80   # Use the 80 chars string to colorize the terminal.
done

# Sets foreground color to black.
echo -ne '\E[30m'

move_and_echo 3 1 &quot;START  1&quot;
move_and_echo 3 75 FINISH
move_and_echo 1 5 &quot;|&quot;
move_and_echo 1 80 &quot;|&quot;
move_and_echo 2 5 &quot;|&quot;
move_and_echo 2 80 &quot;|&quot;
move_and_echo 4 5 &quot;|  2&quot;
move_and_echo 4 80 &quot;|&quot;
move_and_echo 5 5 &quot;V  3&quot;
move_and_echo 5 80 &quot;V&quot;

# Set foreground color to red.
echo -ne '\E[31m'

# Some ASCII art.
move_and_echo 1 8 &quot;..&#64;&#64;&#64;..&#64;&#64;&#64;&#64;&#64;...&#64;&#64;&#64;&#64;&#64;.&#64;...&#64;..&#64;&#64;&#64;&#64;...&quot;
move_and_echo 2 8 &quot;.&#64;...&#64;...&#64;.......&#64;...&#64;...&#64;.&#64;.......&quot;
move_and_echo 3 8 &quot;.&#64;&#64;&#64;&#64;&#64;...&#64;.......&#64;...&#64;&#64;&#64;&#64;&#64;.&#64;&#64;&#64;&#64;....&quot;
move_and_echo 4 8 &quot;.&#64;...&#64;...&#64;.......&#64;...&#64;...&#64;.&#64;.......&quot;
move_and_echo 5 8 &quot;.&#64;...&#64;...&#64;.......&#64;...&#64;...&#64;..&#64;&#64;&#64;&#64;...&quot;
move_and_echo 1 43 &quot;&#64;&#64;&#64;&#64;...&#64;&#64;&#64;...&#64;&#64;&#64;&#64;..&#64;&#64;&#64;&#64;..&#64;&#64;&#64;&#64;.&quot;
move_and_echo 2 43 &quot;&#64;...&#64;.&#64;...&#64;.&#64;.....&#64;.....&#64;.....&quot;
move_and_echo 3 43 &quot;&#64;&#64;&#64;&#64;..&#64;&#64;&#64;&#64;&#64;.&#64;.....&#64;&#64;&#64;&#64;...&#64;&#64;&#64;..&quot;
move_and_echo 4 43 &quot;&#64;..&#64;..&#64;...&#64;.&#64;.....&#64;.........&#64;.&quot;
move_and_echo 5 43 &quot;&#64;...&#64;.&#64;...&#64;..&#64;&#64;&#64;&#64;..&#64;&#64;&#64;&#64;.&#64;&#64;&#64;&#64;..&quot;


# Set foreground and background colors to green.
echo -ne '\E[32;42m'

# Draw  eleven green lines.
tput cup 5 0
for n in `seq 11`; do
      echo $BLANK80
done

# Set foreground color to black.
echo -ne '\E[30m'
tput cup 5 0

# Draw the fences.
echo &quot;++++++++++++++++++++++++++++++++++++++\
++++++++++++++++++++++++++++++++++++++++++&quot;

tput cup 15 0
echo &quot;++++++++++++++++++++++++++++++++++++++\
++++++++++++++++++++++++++++++++++++++++++&quot;

# Set foreground and background colors to white.
echo -ne '\E[37;47m'

# Draw three white lines.
for n in `seq 3`; do
      echo $BLANK80
done

# Set foreground color to black.
echo -ne '\E[30m'

# Create 9 files to stores handicaps.
for n in `seq 10 7 68`; do
      touch $n
done

# Set the first type of &quot;horse&quot; the script will draw.
HORSE_TYPE=2

#  Create position-file and odds-file for every &quot;horse&quot;.
#+ In these files, store the current position of the horse,
#+ the type and the odds.
for HN in `seq 9`; do
      touch horse_${HN}_position
      touch odds_${HN}
      echo \-1 &gt; horse_${HN}_position
      echo $HORSE_TYPE &gt;&gt;  horse_${HN}_position
      # Define a random handicap for horse.
       HANDICAP=`random_1_9`
      # Check if the random_1_9 function returned a good value.
      while ! echo $HANDICAP | grep [1-9] &amp;&gt; /dev/null; do
                HANDICAP=`random_1_9`
      done
      # Define last handicap position for horse.
      LHP=`expr $HANDICAP \* 7 + 3`
      for FILE in `seq 10 7 $LHP`; do
            echo $HN &gt;&gt; $FILE
      done

      # Calculate odds.
      case $HANDICAP in
              1) ODDS=`echo $HANDICAP \* 0.25 + 1.25 | bc`
                                 echo $ODDS &gt; odds_${HN}
              ;;
              2 | 3) ODDS=`echo $HANDICAP \* 0.40 + 1.25 | bc`
                                       echo $ODDS &gt; odds_${HN}
              ;;
              4 | 5 | 6) ODDS=`echo $HANDICAP \* 0.55 + 1.25 | bc`
                                             echo $ODDS &gt; odds_${HN}
              ;;
              7 | 8) ODDS=`echo $HANDICAP \* 0.75 + 1.25 | bc`
                                       echo $ODDS &gt; odds_${HN}
              ;;
              9) ODDS=`echo $HANDICAP \* 0.90 + 1.25 | bc`
                                  echo $ODDS &gt; odds_${HN}
      esac


done


# Print odds.
print_odds() {
tput cup 6 0
echo -ne '\E[30;42m'
for HN in `seq 9`; do
      echo &quot;#$HN odds-&gt;&quot; `cat odds_${HN}`
done
}

# Draw the horses at starting line.
draw_horses() {
tput cup 6 0
echo -ne '\E[30;42m'
for HN in `seq 9`; do
      echo /\\$HN/\\&quot;                               &quot;
done
}

print_odds

echo -ne '\E[47m'
# Wait for a enter key press to start the race.
# The escape sequence '\E[?25l' disables the cursor.
tput cup 17 0
echo -e '\E[?25l'Press [enter] key to start the race...
read -s

#  Disable normal echoing in the terminal.
#  This avoids key presses that might &quot;contaminate&quot; the screen
#+ during the race.
stty -echo

# --------------------------------------------------------
# Start the race.

draw_horses
echo -ne '\E[37;47m'
move_and_echo 18 1 $BLANK80
echo -ne '\E[30m'
move_and_echo 18 1 Starting...
sleep 1

# Set the column of the finish line.
WINNING_POS=74

# Define the time the race started.
START_TIME=`date +%s`

# COL variable needed by following &quot;while&quot; construct.
COL=0

while [ $COL -lt $WINNING_POS ]; do

          MOVE_HORSE=0

          # Check if the random_1_9 function has returned a good value.
          while ! echo $MOVE_HORSE | grep [1-9] &amp;&gt; /dev/null; do
                MOVE_HORSE=`random_1_9`
          done

          # Define old type and position of the &quot;randomized horse&quot;.
          HORSE_TYPE=`cat  horse_${MOVE_HORSE}_position | tail -n 1`
          COL=$(expr `cat  horse_${MOVE_HORSE}_position | head -n 1`)

          ADD_POS=1
          # Check if the current position is an handicap position.
          if seq 10 7 68 | grep -w $COL &amp;&gt; /dev/null; then
                if grep -w $MOVE_HORSE $COL &amp;&gt; /dev/null; then
                      ADD_POS=0
                      grep -v -w  $MOVE_HORSE $COL &gt; ${COL}_new
                      rm -f $COL
                      mv -f ${COL}_new $COL
                      else ADD_POS=1
                fi
          else ADD_POS=1
          fi
          COL=`expr $COL + $ADD_POS`
          echo $COL &gt;  horse_${MOVE_HORSE}_position  # Store new position.

         # Choose the type of horse to draw.
          case $HORSE_TYPE in
                1) HORSE_TYPE=2; DRAW_HORSE=draw_horse_two
                ;;
                2) HORSE_TYPE=1; DRAW_HORSE=draw_horse_one
          esac
          echo $HORSE_TYPE &gt;&gt;  horse_${MOVE_HORSE}_position
          # Store current type.

          # Set foreground color to black and background to green.
          echo -ne '\E[30;42m'

          # Move the cursor to new horse position.
          tput cup `expr $MOVE_HORSE + 5` \
      `cat  horse_${MOVE_HORSE}_position | head -n 1`

          # Draw the horse.
          $DRAW_HORSE
           usleep $USLEEP_ARG

           # When all horses have gone beyond field line 15, reprint odds.
           touch fieldline15
           if [ $COL = 15 ]; then
             echo $MOVE_HORSE &gt;&gt; fieldline15
           fi
           if [ `wc -l fieldline15 | cut -f1 -d &quot; &quot;` = 9 ]; then
               print_odds
               : &gt; fieldline15
           fi

          # Define the leading horse.
          HIGHEST_POS=`cat *position | sort -n | tail -1`

          # Set background color to white.
          echo -ne '\E[47m'
          tput cup 17 0
          echo -n Current leader: `grep -w $HIGHEST_POS *position | cut -c7`\
      &quot;                              &quot;

done

# Define the time the race finished.
FINISH_TIME=`date +%s`

# Set background color to green and enable blinking text.
echo -ne '\E[30;42m'
echo -en '\E[5m'

# Make the winning horse blink.
tput cup `expr $MOVE_HORSE + 5` \
`cat  horse_${MOVE_HORSE}_position | head -n 1`
$DRAW_HORSE

# Disable blinking text.
echo -en '\E[25m'

# Set foreground and background color to white.
echo -ne '\E[37;47m'
move_and_echo 18 1 $BLANK80

# Set foreground color to black.
echo -ne '\E[30m'

# Make winner blink.
tput cup 17 0
echo -e &quot;\E[5mWINNER: $MOVE_HORSE\E[25m&quot;&quot;  Odds: `cat odds_${MOVE_HORSE}`&quot;\
&quot;  Race time: `expr $FINISH_TIME - $START_TIME` secs&quot;

# Restore cursor and old colors.
echo -en &quot;\E[?25h&quot;
echo -en &quot;\E[0m&quot;

# Restore echoing.
stty echo

# Remove race temp directory.
rm -rf $HORSE_RACE_TMP_DIR

tput cup 19 0

exit 0
</pre>
<p>See also <a class="reference external" href="contributed-scripts.html#HASHEXAMPLE">Example A-21</a>,
<a class="reference external" href="contributed-scripts.html#HOMEWORK">Example A-44</a>, <a class="reference external" href="contributed-scripts.html#SHOWALLC">Example
A-52</a>, and <a class="reference external" href="contributed-scripts.html#PETALS">Example
A-40</a>.</p>
<div class="figure align-center">
<img alt="Caution" src="http://tldp.org/LDP/abs/images/caution.gif" />
<p class="caption">Caution</p>
</div>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">rst-ca/colorizing.ca.rst</tt>, line 821)</p>
Explicit markup ends without a blank line; unexpected unindent.</div>
<p>There is, however, a major problem with all this. <em>ANSI escape sequences
are emphatically `non-portable &lt;portabilityissues.html&gt;`_.</em> What works
fine on some terminal emulators (or the console) may work differently,
or not at all, on others. A &quot;colorized&quot; script that looks stunning on
the script author's machine may produce unreadable output on someone
else's. This somewhat compromises the usefulness of colorizing scripts,
and possibly relegates this technique to the status of a gimmick.
Colorized scripts are probably inappropriate in a commercial setting,
i.e., your supervisor might disapprove.</p>
<p>Alister's <a class="reference external" href="http://code.google.com/p/ansi-color/">ansi-color</a> utility
(based on <a class="reference external" href="http://bash.deta.in/color-1.1.tar.gz">Moshe Jacobson's color
utility</a> considerably simplifies
using ANSI escape sequences. It substitutes a clean and logical syntax
for the clumsy constructs just discussed.</p>
<p>Henry/teikedvl has likewise created a utility
(<a class="reference external" href="http://scriptechocolor.sourceforge.net/">http://scriptechocolor.sourceforge.net/</a>)
to simplify creation of colorized scripts.</p>
<div class="section" id="notes">
<h2>Notes</h2>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">rst-ca/colorizing.ca.rst</tt>, line 10); <em><a href="#id2">backlink</a></em></p>
Duplicate explicit target name: &quot;[1]&quot;.</div>
<p><a class="reference external" href="colorizing.html#AEN20101">[1]</a></p>
<p>ANSI is, of course, the acronym for the American National Standards
Institute. This august body establishes and maintains various technical
and industrial standards.</p>
<hr class="docutils" />
<table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="28%" />
<col width="33%" />
</colgroup>
<tbody valign="top">
<tr><td><a class="reference external" href="recursionsct.html">Prev</a></td>
<td><a class="reference external" href="index.html">Home</a></td>
<td><a class="reference external" href="optimizations.html">Next</a></td>
</tr>
<tr><td>Recursion: a script calling itself</td>
<td><a class="reference external" href="miscellany.html">Up</a></td>
<td>Optimizations</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</body>
</html>
