<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.8.1: http://docutils.sourceforge.net/" />
<title></title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7056 2011-06-17 10:50:48Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document">


<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">rst-ca/arrays.ca.rst</tt>, line 1)</p>
<p>Malformed table.</p>
<pre class="literal-block">
+----------------------------------+----+----------------------+
| Advanced Bash-Scripting Guide:   |
+==================================+====+======================+
| `Prev &lt;list-cons.html&gt;`_         |    | `Next &lt;ivr.html&gt;`_   |
+----------------------------------+----+----------------------+
</pre>
</div>
<hr class="docutils" />
<div class="section" id="chapter-27-arrays">
<h1>Chapter 27. Arrays</h1>
<p>Newer versions of Bash support one-dimensional arrays. Array elements
may be initialized with the <tt class="docutils literal">variable[xx]</tt> notation. Alternatively, a
script may introduce the entire array by an explicit
<tt class="docutils literal">declare <span class="pre">-a</span> variable</tt> statement. To dereference (retrieve the contents
of) an array element, use <em>curly bracket</em> notation, that is,
<tt class="docutils literal">${element[xx]}</tt>.</p>
<p><strong>Example 27-1. Simple array usage</strong></p>
<pre class="literal-block">
#!/bin/bash


area[11]=23
area[13]=37
area[51]=UFOs

#  Array members need not be consecutive or contiguous.

#  Some members of the array can be left uninitialized.
#  Gaps in the array are okay.
#  In fact, arrays with sparse data (&quot;sparse arrays&quot;)
#+ are useful in spreadsheet-processing software.


echo -n &quot;area[11] = &quot;
echo ${area[11]}    #  {curly brackets} needed.

echo -n &quot;area[13] = &quot;
echo ${area[13]}

echo &quot;Contents of area[51] are ${area[51]}.&quot;

# Contents of uninitialized array variable print blank (null variable).
echo -n &quot;area[43] = &quot;
echo ${area[43]}
echo &quot;(area[43] unassigned)&quot;

echo

# Sum of two array variables assigned to third
area[5]=`expr ${area[11]} + ${area[13]}`
echo &quot;area[5] = area[11] + area[13]&quot;
echo -n &quot;area[5] = &quot;
echo ${area[5]}

area[6]=`expr ${area[11]} + ${area[51]}`
echo &quot;area[6] = area[11] + area[51]&quot;
echo -n &quot;area[6] = &quot;
echo ${area[6]}
# This fails because adding an integer to a string is not permitted.

echo; echo; echo

# -----------------------------------------------------------------
# Another array, &quot;area2&quot;.
# Another way of assigning array variables...
# array_name=( XXX YYY ZZZ ... )

area2=( zero one two three four )

echo -n &quot;area2[0] = &quot;
echo ${area2[0]}
# Aha, zero-based indexing (first element of array is [0], not [1]).

echo -n &quot;area2[1] = &quot;
echo ${area2[1]}    # [1] is second element of array.
# -----------------------------------------------------------------

echo; echo; echo

# -----------------------------------------------
# Yet another array, &quot;area3&quot;.
# Yet another way of assigning array variables...
# array_name=([xx]=XXX [yy]=YYY ...)

area3=([17]=seventeen [24]=twenty-four)

echo -n &quot;area3[17] = &quot;
echo ${area3[17]}

echo -n &quot;area3[24] = &quot;
echo ${area3[24]}
# -----------------------------------------------

exit 0
</pre>
<p>As we have seen, a convenient way of initializing an entire array is the
<tt class="docutils literal">array=( element1 element2 ... elementN )</tt> notation.</p>
<pre class="literal-block">
base64_charset=( {A..Z} {a..z} {0..9} + / = )
               #  Using extended brace expansion
               #+ to initialize the elements of the array.
               #  Excerpted from vladz's &quot;base64.sh&quot; script
               #+ in the &quot;Contributed Scripts&quot; appendix.
</pre>
<p>Bash permits array operations on variables, even if the variables are
not explicitly declared as arrays.</p>
<pre class="literal-block">
string=abcABC123ABCabc
echo ${string[&#64;]}               # abcABC123ABCabc
echo ${string[*]}               # abcABC123ABCabc
echo ${string[0]}               # abcABC123ABCabc
echo ${string[1]}               # No output!
                                # Why?
echo ${#string[&#64;]}              # 1
                                # One element in the array.
                                # The string itself.

# Thank you, Michael Zick, for pointing this out.
</pre>
<p>Once again this demonstrates that <a class="reference external" href="untyped.html#BVUNTYPED">Bash variables are
untyped</a>.</p>
<p><strong>Example 27-2. Formatting a poem</strong></p>
<pre class="literal-block">
#!/bin/bash
# poem.sh: Pretty-prints one of the ABS Guide author's favorite poems.

# Lines of the poem (single stanza).
Line[1]=&quot;I do not know which to prefer,&quot;
Line[2]=&quot;The beauty of inflections&quot;
Line[3]=&quot;Or the beauty of innuendoes,&quot;
Line[4]=&quot;The blackbird whistling&quot;
Line[5]=&quot;Or just after.&quot;
# Note that quoting permits embedding whitespace.

# Attribution.
Attrib[1]=&quot; Wallace Stevens&quot;
Attrib[2]=&quot;\&quot;Thirteen Ways of Looking at a Blackbird\&quot;&quot;
# This poem is in the Public Domain (copyright expired).

echo

tput bold   # Bold print.

for index in 1 2 3 4 5    # Five lines.
do
  printf &quot;     %s\n&quot; &quot;${Line[index]}&quot;
done

for index in 1 2          # Two attribution lines.
do
  printf &quot;          %s\n&quot; &quot;${Attrib[index]}&quot;
done

tput sgr0   # Reset terminal.
            # See 'tput' docs.

echo

exit 0

# Exercise:
# --------
# Modify this script to pretty-print a poem from a text data file.
</pre>
<p>Array variables have a syntax all their own, and even standard Bash
commands and operators have special options adapted for array use.</p>
<p><strong>Example 27-3. Various array operations</strong></p>
<pre class="literal-block">
#!/bin/bash
# array-ops.sh: More fun with arrays.


array=( zero one two three four five )
# Element 0   1   2    3     4    5

echo ${array[0]}       #  zero
echo ${array:0}        #  zero
                       #  Parameter expansion of first element,
                       #+ starting at position # 0 (1st character).
echo ${array:1}        #  ero
                       #  Parameter expansion of first element,
                       #+ starting at position # 1 (2nd character).

echo &quot;--------------&quot;

echo ${#array[0]}      #  4
                       #  Length of first element of array.
echo ${#array}         #  4
                       #  Length of first element of array.
                       #  (Alternate notation)

echo ${#array[1]}      #  3
                       #  Length of second element of array.
                       #  Arrays in Bash have zero-based indexing.

echo ${#array[*]}      #  6
                       #  Number of elements in array.
echo ${#array[&#64;]}      #  6
                       #  Number of elements in array.

echo &quot;--------------&quot;

array2=( [0]=&quot;first element&quot; [1]=&quot;second element&quot; [3]=&quot;fourth element&quot; )
#            ^     ^       ^     ^      ^       ^     ^      ^       ^
# Quoting permits embedding whitespace within individual array elements.

echo ${array2[0]}      # first element
echo ${array2[1]}      # second element
echo ${array2[2]}      #
                       # Skipped in initialization, and therefore null.
echo ${array2[3]}      # fourth element
echo ${#array2[0]}     # 13    (length of first element)
echo ${#array2[*]}     # 3     (number of elements in array)

exit
</pre>
<p>Many of the standard <a class="reference external" href="string-manipulation.html#STRINGMANIP">string
operations</a> work on arrays.</p>
<p><strong>Example 27-4. String operations on arrays</strong></p>
<pre class="literal-block">
#!/bin/bash
# array-strops.sh: String operations on arrays.

# Script by Michael Zick.
# Used in ABS Guide with permission.
# Fixups: 05 May 08, 04 Aug 08.

#  In general, any string operation using the ${name ... } notation
#+ can be applied to all string elements in an array,
#+ with the ${name[&#64;] ... } or ${name[*] ...} notation.


arrayZ=( one two three four five five )

echo

# Trailing Substring Extraction
echo ${arrayZ[&#64;]:0}     # one two three four five five
#                ^        All elements.

echo ${arrayZ[&#64;]:1}     # two three four five five
#                ^        All elements following element[0].

echo ${arrayZ[&#64;]:1:2}   # two three
#                  ^      Only the two elements after element[0].

echo &quot;---------&quot;


# Substring Removal

# Removes shortest match from front of string(s).

echo ${arrayZ[&#64;]#f*r}   # one two three five five
#               ^       # Applied to all elements of the array.
                        # Matches &quot;four&quot; and removes it.

# Longest match from front of string(s)
echo ${arrayZ[&#64;]##t*e}  # one two four five five
#               ^^      # Applied to all elements of the array.
                        # Matches &quot;three&quot; and removes it.

# Shortest match from back of string(s)
echo ${arrayZ[&#64;]%h*e}   # one two t four five five
#               ^       # Applied to all elements of the array.
                        # Matches &quot;hree&quot; and removes it.

# Longest match from back of string(s)
echo ${arrayZ[&#64;]%%t*e}  # one two four five five
#               ^^      # Applied to all elements of the array.
                        # Matches &quot;three&quot; and removes it.

echo &quot;----------------------&quot;


# Substring Replacement

# Replace first occurrence of substring with replacement.
echo ${arrayZ[&#64;]/fiv/XYZ}   # one two three four XYZe XYZe
#               ^           # Applied to all elements of the array.

# Replace all occurrences of substring.
echo ${arrayZ[&#64;]//iv/YY}    # one two three four fYYe fYYe
                            # Applied to all elements of the array.

# Delete all occurrences of substring.
# Not specifing a replacement defaults to 'delete' ...
echo ${arrayZ[&#64;]//fi/}      # one two three four ve ve
#               ^^          # Applied to all elements of the array.

# Replace front-end occurrences of substring.
echo ${arrayZ[&#64;]/#fi/XY}    # one two three four XYve XYve
#                ^          # Applied to all elements of the array.

# Replace back-end occurrences of substring.
echo ${arrayZ[&#64;]/%ve/ZZ}    # one two three four fiZZ fiZZ
#                ^          # Applied to all elements of the array.

echo ${arrayZ[&#64;]/%o/XX}     # one twXX three four five five
#                ^          # Why?

echo &quot;-----------------------------&quot;


replacement() {
    echo -n &quot;!!!&quot;
}

echo ${arrayZ[&#64;]/%e/$(replacement)}
#                ^  ^^^^^^^^^^^^^^
# on!!! two thre!!! four fiv!!! fiv!!!
# The stdout of replacement() is the replacement string.
# Q.E.D: The replacement action is, in effect, an 'assignment.'

echo &quot;------------------------------------&quot;

#  Accessing the &quot;for-each&quot;:
echo ${arrayZ[&#64;]//*/$(replacement optional_arguments)}
#                ^^ ^^^^^^^^^^^^^
# !!! !!! !!! !!! !!! !!!

#  Now, if Bash would only pass the matched string
#+ to the function being called . . .

echo

exit 0

#  Before reaching for a Big Hammer -- Perl, Python, or all the rest --
#  recall:
#    $( ... ) is command substitution.
#    A function runs as a sub-process.
#    A function writes its output (if echo-ed) to stdout.
#    Assignment, in conjunction with &quot;echo&quot; and command substitution,
#+   can read a function's stdout.
#    The name[&#64;] notation specifies (the equivalent of) a &quot;for-each&quot;
#+   operation.
#  Bash is more powerful than you think!
</pre>
<p><a class="reference external" href="commandsub.html#COMMANDSUBREF">Command substitution</a> can construct
the individual elements of an array.</p>
<p><strong>Example 27-5. Loading the contents of a script into an array</strong></p>
<pre class="literal-block">
#!/bin/bash
# script-array.sh: Loads this script into an array.
# Inspired by an e-mail from Chris Martin (thanks!).

script_contents=( $(cat &quot;$0&quot;) )  #  Stores contents of this script ($0)
                                 #+ in an array.

for element in $(seq 0 $((${#script_contents[&#64;]} - 1)))
  do                #  ${#script_contents[&#64;]}
                    #+ gives number of elements in the array.
                    #
                    #  Question:
                    #  Why is  seq 0  necessary?
                    #  Try changing it to seq 1.
  echo -n &quot;${script_contents[$element]}&quot;
                    # List each field of this script on a single line.
# echo -n &quot;${script_contents[element]}&quot; also works because of ${ ... }.
  echo -n &quot; -- &quot;    # Use &quot; -- &quot; as a field separator.
done

echo

exit 0

# Exercise:
# --------
#  Modify this script so it lists itself
#+ in its original format,
#+ complete with whitespace, line breaks, etc.
</pre>
<p>In an array context, some Bash <a class="reference external" href="internal.html#BUILTINREF">builtins</a>
have a slightly altered meaning. For example,
<a class="reference external" href="internal.html#UNSETREF">unset</a> deletes array elements, or even an
entire array.</p>
<p><strong>Example 27-6. Some special properties of arrays</strong></p>
<pre class="literal-block">
#!/bin/bash

declare -a colors
#  All subsequent commands in this script will treat
#+ the variable &quot;colors&quot; as an array.

echo &quot;Enter your favorite colors (separated from each other by a space).&quot;

read -a colors    # Enter at least 3 colors to demonstrate features below.
#  Special option to 'read' command,
#+ allowing assignment of elements in an array.

echo

element_count=${#colors[&#64;]}
# Special syntax to extract number of elements in array.
#     element_count=${#colors[*]} works also.
#
#  The &quot;&#64;&quot; variable allows word splitting within quotes
#+ (extracts variables separated by whitespace).
#
#  This corresponds to the behavior of &quot;$&#64;&quot; and &quot;$*&quot;
#+ in positional parameters.

index=0

while [ &quot;$index&quot; -lt &quot;$element_count&quot; ]
do    # List all the elements in the array.
  echo ${colors[$index]}
  #    ${colors[index]} also works because it's within ${ ... } brackets.
  let &quot;index = $index + 1&quot;
  # Or:
  #    ((index++))
done
# Each array element listed on a separate line.
# If this is not desired, use  echo -n &quot;${colors[$index]} &quot;
#
# Doing it with a &quot;for&quot; loop instead:
#   for i in &quot;${colors[&#64;]}&quot;
#   do
#     echo &quot;$i&quot;
#   done
# (Thanks, S.C.)

echo

# Again, list all the elements in the array, but using a more elegant method.
  echo ${colors[&#64;]}          # echo ${colors[*]} also works.

echo

# The &quot;unset&quot; command deletes elements of an array, or entire array.
unset colors[1]              # Remove 2nd element of array.
                             # Same effect as   colors[1]=
echo  ${colors[&#64;]}           # List array again, missing 2nd element.

unset colors                 # Delete entire array.
                             #  unset colors[*] and
                             #+ unset colors[&#64;] also work.
echo; echo -n &quot;Colors gone.&quot;
echo ${colors[&#64;]}            # List array again, now empty.

exit 0
</pre>
<p>As seen in the previous example, either <strong>${array_name[&#64;]}</strong> or
<strong>${array_name[*]}</strong> refers to <em>all</em> the elements of the array.
Similarly, to get a count of the number of elements in an array, use
either <strong>${#array_name[&#64;]}</strong> or <strong>${#array_name[*]}</strong>.
<strong>${#array_name}</strong> is the length (number of characters) of
<strong>${array_name[0]}</strong>, the first element of the array.</p>
<p><strong>Example 27-7. Of empty arrays and empty elements</strong></p>
<pre class="literal-block">
#!/bin/bash
# empty-array.sh

#  Thanks to Stephane Chazelas for the original example,
#+ and to Michael Zick and Omair Eshkenazi, for extending it.
#  And to Nathan Coulter for clarifications and corrections.


# An empty array is not the same as an array with empty elements.

  array0=( first second third )
  array1=( '' )   # &quot;array1&quot; consists of one empty element.
  array2=( )      # No elements . . . &quot;array2&quot; is empty.
  array3=(   )    # What about this array?


echo
ListArray()
{
echo
echo &quot;Elements in array0:  ${array0[&#64;]}&quot;
echo &quot;Elements in array1:  ${array1[&#64;]}&quot;
echo &quot;Elements in array2:  ${array2[&#64;]}&quot;
echo &quot;Elements in array3:  ${array3[&#64;]}&quot;
echo
echo &quot;Length of first element in array0 = ${#array0}&quot;
echo &quot;Length of first element in array1 = ${#array1}&quot;
echo &quot;Length of first element in array2 = ${#array2}&quot;
echo &quot;Length of first element in array3 = ${#array3}&quot;
echo
echo &quot;Number of elements in array0 = ${#array0[*]}&quot;  # 3
echo &quot;Number of elements in array1 = ${#array1[*]}&quot;  # 1  (Surprise!)
echo &quot;Number of elements in array2 = ${#array2[*]}&quot;  # 0
echo &quot;Number of elements in array3 = ${#array3[*]}&quot;  # 0
}

# ===================================================================

ListArray

# Try extending those arrays.

# Adding an element to an array.
array0=( &quot;${array0[&#64;]}&quot; &quot;new1&quot; )
array1=( &quot;${array1[&#64;]}&quot; &quot;new1&quot; )
array2=( &quot;${array2[&#64;]}&quot; &quot;new1&quot; )
array3=( &quot;${array3[&#64;]}&quot; &quot;new1&quot; )

ListArray

# or
array0[${#array0[*]}]=&quot;new2&quot;
array1[${#array1[*]}]=&quot;new2&quot;
array2[${#array2[*]}]=&quot;new2&quot;
array3[${#array3[*]}]=&quot;new2&quot;

ListArray

# When extended as above, arrays are 'stacks' ...
# Above is the 'push' ...
# The stack 'height' is:
height=${#array2[&#64;]}
echo
echo &quot;Stack height for array2 = $height&quot;

# The 'pop' is:
unset array2[${#array2[&#64;]}-1]   #  Arrays are zero-based,
height=${#array2[&#64;]}            #+ which means first element has index 0.
echo
echo &quot;POP&quot;
echo &quot;New stack height for array2 = $height&quot;

ListArray

# List only 2nd and 3rd elements of array0.
from=1          # Zero-based numbering.
to=2
array3=( ${array0[&#64;]:1:2} )
echo
echo &quot;Elements in array3:  ${array3[&#64;]}&quot;

# Works like a string (array of characters).
# Try some other &quot;string&quot; forms.

# Replacement:
array4=( ${array0[&#64;]/second/2nd} )
echo
echo &quot;Elements in array4:  ${array4[&#64;]}&quot;

# Replace all matching wildcarded string.
array5=( ${array0[&#64;]//new?/old} )
echo
echo &quot;Elements in array5:  ${array5[&#64;]}&quot;

# Just when you are getting the feel for this . . .
array6=( ${array0[&#64;]#*new} )
echo # This one might surprise you.
echo &quot;Elements in array6:  ${array6[&#64;]}&quot;

array7=( ${array0[&#64;]#new1} )
echo # After array6 this should not be a surprise.
echo &quot;Elements in array7:  ${array7[&#64;]}&quot;

# Which looks a lot like . . .
array8=( ${array0[&#64;]/new1/} )
echo
echo &quot;Elements in array8:  ${array8[&#64;]}&quot;

#  So what can one say about this?

#  The string operations are performed on
#+ each of the elements in var[&#64;] in succession.
#  Therefore : Bash supports string vector operations.
#  If the result is a zero length string,
#+ that element disappears in the resulting assignment.
#  However, if the expansion is in quotes, the null elements remain.

#  Michael Zick:    Question, are those strings hard or soft quotes?
#  Nathan Coulter:  There is no such thing as &quot;soft quotes.&quot;
#!    What's really happening is that
#!+   the pattern matching happens after
#!+   all the other expansions of [word]
#!+   in cases like ${parameter#word}.


zap='new*'
array9=( ${array0[&#64;]/$zap/} )
echo
echo &quot;Number of elements in array9:  ${#array9[&#64;]}&quot;
array9=( &quot;${array0[&#64;]/$zap/}&quot; )
echo &quot;Elements in array9:  ${array9[&#64;]}&quot;
# This time the null elements remain.
echo &quot;Number of elements in array9:  ${#array9[&#64;]}&quot;


# Just when you thought you were still in Kansas . . .
array10=( ${array0[&#64;]#$zap} )
echo
echo &quot;Elements in array10:  ${array10[&#64;]}&quot;
# But, the asterisk in zap won't be interpreted if quoted.
array10=( ${array0[&#64;]#&quot;$zap&quot;} )
echo
echo &quot;Elements in array10:  ${array10[&#64;]}&quot;
# Well, maybe we _are_ still in Kansas . . .
# (Revisions to above code block by Nathan Coulter.)


#  Compare array7 with array10.
#  Compare array8 with array9.

#  Reiterating: No such thing as soft quotes!
#  Nathan Coulter explains:
#  Pattern matching of 'word' in ${parameter#word} is done after
#+ parameter expansion and *before* quote removal.
#  In the normal case, pattern matching is done *after* quote removal.

exit
</pre>
<p>The relationship of <strong>${array_name[&#64;]}</strong> and <strong>${array_name[*]}</strong> is
analogous to that between <a class="reference external" href="internalvariables.html#APPREF">$&#64; and $*</a>.
This powerful array notation has a number of uses.</p>
<pre class="literal-block">
# Copying an array.
array2=( &quot;${array1[&#64;]}&quot; )
# or
array2=&quot;${array1[&#64;]}&quot;
#
#  However, this fails with &quot;sparse&quot; arrays,
#+ arrays with holes (missing elements) in them,
#+ as Jochen DeSmet points out.
# ------------------------------------------
  array1[0]=0
# array1[1] not assigned
  array1[2]=2
  array2=( &quot;${array1[&#64;]}&quot; )       # Copy it?

echo ${array2[0]}      # 0
echo ${array2[2]}      # (null), should be 2
# ------------------------------------------



# Adding an element to an array.
array=( &quot;${array[&#64;]}&quot; &quot;new element&quot; )
# or
array[${#array[*]}]=&quot;new element&quot;

# Thanks, S.C.
</pre>
<div class="figure align-center">
<img alt="Tip" src="http://tldp.org/LDP/abs/images/tip.gif" />
<p class="caption">Tip</p>
</div>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">rst-ca/arrays.ca.rst</tt>, line 674)</p>
Explicit markup ends without a blank line; unexpected unindent.</div>
<p>The <strong>array=( element1 element2 ... elementN )</strong> initialization
operation, with the help of <a class="reference external" href="commandsub.html#COMMANDSUBREF">command
substitution</a>, makes it possible to
load the contents of a text file into an array.</p>
<pre class="literal-block">
#!/bin/bash

filename=sample_file

#            cat sample_file
#
#            1 a b c
#            2 d e fg


declare -a array1

array1=( `cat &quot;$filename&quot;`)                #  Loads contents
#         List file to stdout              #+ of $filename into array1.
#
#  array1=( `cat &quot;$filename&quot; | tr '\n' ' '`)
#                            change linefeeds in file to spaces.
#  Not necessary because Bash does word splitting,
#+ changing linefeeds to spaces.

echo ${array1[&#64;]}            # List the array.
#                              1 a b c 2 d e fg
#
#  Each whitespace-separated &quot;word&quot; in the file
#+ has been assigned to an element of the array.

element_count=${#array1[*]}
echo $element_count          # 8
</pre>
<p>Clever scripting makes it possible to add array operations.</p>
<p><strong>Example 27-8. Initializing arrays</strong></p>
<pre class="literal-block">
#! /bin/bash
# array-assign.bash

#  Array operations are Bash-specific,
#+ hence the &quot;.bash&quot; in the script name.

# Copyright (c) Michael S. Zick, 2003, All rights reserved.
# License: Unrestricted reuse in any form, for any purpose.
# Version: $ID$
#
# Clarification and additional comments by William Park.

#  Based on an example provided by Stephane Chazelas
#+ which appeared in an earlier version of the
#+ Advanced Bash Scripting Guide.

# Output format of the 'times' command:
# User CPU &lt;space&gt; System CPU
# User CPU of dead children &lt;space&gt; System CPU of dead children

#  Bash has two versions of assigning all elements of an array
#+ to a new array variable.
#  Both drop 'null reference' elements
#+ in Bash versions 2.04 and later.
#  An additional array assignment that maintains the relationship of
#+ [subscript]=value for arrays may be added to newer versions.

#  Constructs a large array using an internal command,
#+ but anything creating an array of several thousand elements
#+ will do just fine.

declare -a bigOne=( /dev/* )  # All the files in /dev . . .
echo
echo 'Conditions: Unquoted, default IFS, All-Elements-Of'
echo &quot;Number of elements in array is ${#bigOne[&#64;]}&quot;

# set -vx



echo
echo '- - testing: =( ${array[&#64;]} ) - -'
times
declare -a bigTwo=( ${bigOne[&#64;]} )
# Note parens:    ^              ^
times


echo
echo '- - testing: =${array[&#64;]} - -'
times
declare -a bigThree=${bigOne[&#64;]}
# No parentheses this time.
times

#  Comparing the numbers shows that the second form, pointed out
#+ by Stephane Chazelas, is faster.
#
#  As William Park explains:
#+ The bigTwo array assigned element by element (because of parentheses),
#+ whereas bigThree assigned as a single string.
#  So, in essence, you have:
#                   bigTwo=( [0]=&quot;...&quot; [1]=&quot;...&quot; [2]=&quot;...&quot; ... )
#                   bigThree=( [0]=&quot;... ... ...&quot; )
#
#  Verify this by:  echo ${bigTwo[0]}
#                   echo ${bigThree[0]}


#  I will continue to use the first form in my example descriptions
#+ because I think it is a better illustration of what is happening.

#  The reusable portions of my examples will actual contain
#+ the second form where appropriate because of the speedup.

# MSZ: Sorry about that earlier oversight folks.


#  Note:
#  ----
#  The &quot;declare -a&quot; statements in lines 32 and 44
#+ are not strictly necessary, since it is implicit
#+ in the  Array=( ... )  assignment form.
#  However, eliminating these declarations slows down
#+ the execution of the following sections of the script.
#  Try it, and see.

exit 0
</pre>
<div class="figure align-center">
<img alt="Note" src="http://tldp.org/LDP/abs/images/note.gif" />
<p class="caption">Note</p>
</div>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">rst-ca/arrays.ca.rst</tt>, line 810)</p>
Explicit markup ends without a blank line; unexpected unindent.</div>
<p>Adding a superfluous <strong>declare -a</strong> statement to an array declaration
may speed up execution of subsequent operations on the array.</p>
<p><strong>Example 27-9. Copying and concatenating arrays</strong></p>
<pre class="literal-block">
#! /bin/bash
# CopyArray.sh
#
# This script written by Michael Zick.
# Used here with permission.

#  How-To &quot;Pass by Name &amp; Return by Name&quot;
#+ or &quot;Building your own assignment statement&quot;.


CpArray_Mac() {

# Assignment Command Statement Builder

    echo -n 'eval '
    echo -n &quot;$2&quot;                    # Destination name
    echo -n '=( ${'
    echo -n &quot;$1&quot;                    # Source name
    echo -n '[&#64;]} )'

# That could all be a single command.
# Matter of style only.
}

declare -f CopyArray                # Function &quot;Pointer&quot;
CopyArray=CpArray_Mac               # Statement Builder

Hype()
{

# Hype the array named $1.
# (Splice it together with array containing &quot;Really Rocks&quot;.)
# Return in array named $2.

    local -a TMP
    local -a hype=( Really Rocks )

    $($CopyArray $1 TMP)
    TMP=( ${TMP[&#64;]} ${hype[&#64;]} )
    $($CopyArray TMP $2)
}

declare -a before=( Advanced Bash Scripting )
declare -a after

echo &quot;Array Before = ${before[&#64;]}&quot;

Hype before after

echo &quot;Array After = ${after[&#64;]}&quot;

# Too much hype?

echo &quot;What ${after[&#64;]:3:2}?&quot;

declare -a modest=( ${after[&#64;]:2:1} ${after[&#64;]:3:2} )
#                    ---- substring extraction ----

echo &quot;Array Modest = ${modest[&#64;]}&quot;

# What happened to 'before' ?

echo &quot;Array Before = ${before[&#64;]}&quot;

exit 0
</pre>
<p><strong>Example 27-10. More on concatenating arrays</strong></p>
<pre class="literal-block">
#! /bin/bash
# array-append.bash

# Copyright (c) Michael S. Zick, 2003, All rights reserved.
# License: Unrestricted reuse in any form, for any purpose.
# Version: $ID$
#
# Slightly modified in formatting by M.C.


# Array operations are Bash-specific.
# Legacy UNIX /bin/sh lacks equivalents.


#  Pipe the output of this script to 'more'
#+ so it doesn't scroll off the terminal.
#  Or, redirect output to a file.


declare -a array1=( zero1 one1 two1 )
# Subscript packed.
declare -a array2=( [0]=zero2 [2]=two2 [3]=three2 )
# Subscript sparse -- [1] is not defined.

echo
echo '- Confirm that the array is really subscript sparse. -'
echo &quot;Number of elements: 4&quot;        # Hard-coded for illustration.
for (( i = 0 ; i &lt; 4 ; i++ ))
do
    echo &quot;Element [$i]: ${array2[$i]}&quot;
done
# See also the more general code example in basics-reviewed.bash.


declare -a dest

# Combine (append) two arrays into a third array.
echo
echo 'Conditions: Unquoted, default IFS, All-Elements-Of operator'
echo '- Undefined elements not present, subscripts not maintained. -'
# # The undefined elements do not exist; they are not being dropped.

dest=( ${array1[&#64;]} ${array2[&#64;]} )
# dest=${array1[&#64;]}${array2[&#64;]}     # Strange results, possibly a bug.

# Now, list the result.
echo
echo '- - Testing Array Append - -'
cnt=${#dest[&#64;]}

echo &quot;Number of elements: $cnt&quot;
for (( i = 0 ; i &lt; cnt ; i++ ))
do
    echo &quot;Element [$i]: ${dest[$i]}&quot;
done

# Assign an array to a single array element (twice).
dest[0]=${array1[&#64;]}
dest[1]=${array2[&#64;]}

# List the result.
echo
echo '- - Testing modified array - -'
cnt=${#dest[&#64;]}

echo &quot;Number of elements: $cnt&quot;
for (( i = 0 ; i &lt; cnt ; i++ ))
do
    echo &quot;Element [$i]: ${dest[$i]}&quot;
done

# Examine the modified second element.
echo
echo '- - Reassign and list second element - -'

declare -a subArray=${dest[1]}
cnt=${#subArray[&#64;]}

echo &quot;Number of elements: $cnt&quot;
for (( i = 0 ; i &lt; cnt ; i++ ))
do
    echo &quot;Element [$i]: ${subArray[$i]}&quot;
done

#  The assignment of an entire array to a single element
#+ of another array using the '=${ ... }' array assignment
#+ has converted the array being assigned into a string,
#+ with the elements separated by a space (the first character of IFS).

# If the original elements didn't contain whitespace . . .
# If the original array isn't subscript sparse . . .
# Then we could get the original array structure back again.

# Restore from the modified second element.
echo
echo '- - Listing restored element - -'

declare -a subArray=( ${dest[1]} )
cnt=${#subArray[&#64;]}

echo &quot;Number of elements: $cnt&quot;
for (( i = 0 ; i &lt; cnt ; i++ ))
do
    echo &quot;Element [$i]: ${subArray[$i]}&quot;
done
echo '- - Do not depend on this behavior. - -'
echo '- - This behavior is subject to change - -'
echo '- - in versions of Bash newer than version 2.05b - -'

# MSZ: Sorry about any earlier confusion folks.

exit 0
</pre>
<p>--</p>
<p>Arrays permit deploying old familiar algorithms as shell scripts.
Whether this is necessarily a good idea is left for the reader to
decide.</p>
<p><strong>Example 27-11. The Bubble Sort</strong></p>
<pre class="literal-block">
#!/bin/bash
# bubble.sh: Bubble sort, of sorts.

# Recall the algorithm for a bubble sort. In this particular version...

#  With each successive pass through the array to be sorted,
#+ compare two adjacent elements, and swap them if out of order.
#  At the end of the first pass, the &quot;heaviest&quot; element has sunk to bottom.
#  At the end of the second pass, the next &quot;heaviest&quot; one has sunk next to bottom.
#  And so forth.
#  This means that each successive pass needs to traverse less of the array.
#  You will therefore notice a speeding up in the printing of the later passes.


exchange()
{
  # Swaps two members of the array.
  local temp=${Countries[$1]} #  Temporary storage
                              #+ for element getting swapped out.
  Countries[$1]=${Countries[$2]}
  Countries[$2]=$temp

  return
}

declare -a Countries  #  Declare array,
                      #+ optional here since it's initialized below.

#  Is it permissable to split an array variable over multiple lines
#+ using an escape (\)?
#  Yes.

Countries=(Netherlands Ukraine Zaire Turkey Russia Yemen Syria \
Brazil Argentina Nicaragua Japan Mexico Venezuela Greece England \
Israel Peru Canada Oman Denmark Wales France Kenya \
Xanadu Qatar Liechtenstein Hungary)

# &quot;Xanadu&quot; is the mythical place where, according to Coleridge,
#+ Kubla Khan did a pleasure dome decree.


clear                      # Clear the screen to start with.

echo &quot;0: ${Countries[*]}&quot;  # List entire array at pass 0.

number_of_elements=${#Countries[&#64;]}
let &quot;comparisons = $number_of_elements - 1&quot;

count=1 # Pass number.

while [ &quot;$comparisons&quot; -gt 0 ]          # Beginning of outer loop
do

  index=0  # Reset index to start of array after each pass.

  while [ &quot;$index&quot; -lt &quot;$comparisons&quot; ] # Beginning of inner loop
  do
    if [ ${Countries[$index]} \&gt; ${Countries[`expr $index + 1`]} ]
    #  If out of order...
    #  Recalling that \&gt; is ASCII comparison operator
    #+ within single brackets.

    #  if [[ ${Countries[$index]} &gt; ${Countries[`expr $index + 1`]} ]]
    #+ also works.
    then
      exchange $index `expr $index + 1`  # Swap.
    fi
    let &quot;index += 1&quot;  # Or,   index+=1   on Bash, ver. 3.1 or newer.
  done # End of inner loop

# ----------------------------------------------------------------------
# Paulo Marcel Coelho Aragao suggests for-loops as a simpler altenative.
#
# for (( last = $number_of_elements - 1 ; last &gt; 0 ; last-- ))
##                     Fix by C.Y. Hunt          ^   (Thanks!)
# do
#     for (( i = 0 ; i &lt; last ; i++ ))
#     do
#         [[ &quot;${Countries[$i]}&quot; &gt; &quot;${Countries[$((i+1))]}&quot; ]] \
#             &amp;&amp; exchange $i $((i+1))
#     done
# done
# ----------------------------------------------------------------------


let &quot;comparisons -= 1&quot; #  Since &quot;heaviest&quot; element bubbles to bottom,
                       #+ we need do one less comparison each pass.

echo
echo &quot;$count: ${Countries[&#64;]}&quot;  # Print resultant array at end of each pass.
echo
let &quot;count += 1&quot;                # Increment pass count.

done                            # End of outer loop
                                # All done.

exit 0
</pre>
<p>--</p>
<p>Is it possible to nest arrays within arrays?</p>
<pre class="literal-block">
#!/bin/bash
# &quot;Nested&quot; array.

#  Michael Zick provided this example,
#+ with corrections and clarifications by William Park.

AnArray=( $(ls --inode --ignore-backups --almost-all \
    --directory --full-time --color=none --time=status \
    --sort=time -l ${PWD} ) )  # Commands and options.

# Spaces are significant . . . and don't quote anything in the above.

SubArray=( ${AnArray[&#64;]:11:1}  ${AnArray[&#64;]:6:5} )
#  This array has six elements:
#+     SubArray=( [0]=${AnArray[11]} [1]=${AnArray[6]} [2]=${AnArray[7]}
#      [3]=${AnArray[8]} [4]=${AnArray[9]} [5]=${AnArray[10]} )
#
#  Arrays in Bash are (circularly) linked lists
#+ of type string (char *).
#  So, this isn't actually a nested array,
#+ but it's functionally similar.

echo &quot;Current directory and date of last status change:&quot;
echo &quot;${SubArray[&#64;]}&quot;

exit 0
</pre>
<p>--</p>
<p>Embedded arrays in combination with <a class="reference external" href="bashver2.html#VARREFNEW">indirect
references</a> create some fascinating
possibilities</p>
<p><strong>Example 27-12. Embedded arrays and indirect references</strong></p>
<pre class="literal-block">
#!/bin/bash
# embedded-arrays.sh
# Embedded arrays and indirect references.

# This script by Dennis Leeuw.
# Used with permission.
# Modified by document author.


ARRAY1=(
        VAR1_1=value11
        VAR1_2=value12
        VAR1_3=value13
)

ARRAY2=(
        VARIABLE=&quot;test&quot;
        STRING=&quot;VAR1=value1 VAR2=value2 VAR3=value3&quot;
        ARRAY21=${ARRAY1[*]}
)       # Embed ARRAY1 within this second array.

function print () {
        OLD_IFS=&quot;$IFS&quot;
        IFS=$'\n'       #  To print each array element
                        #+ on a separate line.
        TEST1=&quot;ARRAY2[*]&quot;
        local ${!TEST1} # See what happens if you delete this line.
        #  Indirect reference.
    #  This makes the components of $TEST1
    #+ accessible to this function.


        #  Let's see what we've got so far.
        echo
        echo &quot;\$TEST1 = $TEST1&quot;       #  Just the name of the variable.
        echo; echo
        echo &quot;{\$TEST1} = ${!TEST1}&quot;  #  Contents of the variable.
                                      #  That's what an indirect
                                      #+ reference does.
        echo
        echo &quot;-------------------------------------------&quot;; echo
        echo


        # Print variable
        echo &quot;Variable VARIABLE: $VARIABLE&quot;

        # Print a string element
        IFS=&quot;$OLD_IFS&quot;
        TEST2=&quot;STRING[*]&quot;
        local ${!TEST2}      # Indirect reference (as above).
        echo &quot;String element VAR2: $VAR2 from STRING&quot;

        # Print an array element
        TEST2=&quot;ARRAY21[*]&quot;
        local ${!TEST2}      # Indirect reference (as above).
        echo &quot;Array element VAR1_1: $VAR1_1 from ARRAY21&quot;
}

print
echo

exit 0

#   As the author of the script notes,
#+ &quot;you can easily expand it to create named-hashes in bash.&quot;
#   (Difficult) exercise for the reader: implement this.
</pre>
<p>--</p>
<p>Arrays enable implementing a shell script version of the <em>Sieve of
Eratosthenes</em>. Of course, a resource-intensive application of this
nature should really be written in a compiled language, such as C. It
runs excruciatingly slowly as a script.</p>
<p><strong>Example 27-13. The Sieve of Eratosthenes</strong></p>
<pre class="literal-block">
#!/bin/bash
# sieve.sh (ex68.sh)

# Sieve of Eratosthenes
# Ancient algorithm for finding prime numbers.

#  This runs a couple of orders of magnitude slower
#+ than the equivalent program written in C.

LOWER_LIMIT=1       # Starting with 1.
UPPER_LIMIT=1000    # Up to 1000.
# (You may set this higher . . . if you have time on your hands.)

PRIME=1
NON_PRIME=0

let SPLIT=UPPER_LIMIT/2
# Optimization:
# Need to test numbers only halfway to upper limit. Why?


declare -a Primes
# Primes[] is an array.


initialize ()
{
# Initialize the array.

i=$LOWER_LIMIT
until [ &quot;$i&quot; -gt &quot;$UPPER_LIMIT&quot; ]
do
  Primes[i]=$PRIME
  let &quot;i += 1&quot;
done
#  Assume all array members guilty (prime)
#+ until proven innocent.
}

print_primes ()
{
# Print out the members of the Primes[] array tagged as prime.

i=$LOWER_LIMIT

until [ &quot;$i&quot; -gt &quot;$UPPER_LIMIT&quot; ]
do

  if [ &quot;${Primes[i]}&quot; -eq &quot;$PRIME&quot; ]
  then
    printf &quot;%8d&quot; $i
    # 8 spaces per number gives nice, even columns.
  fi

  let &quot;i += 1&quot;

done

}

sift () # Sift out the non-primes.
{

let i=$LOWER_LIMIT+1
# Let's start with 2.

until [ &quot;$i&quot; -gt &quot;$UPPER_LIMIT&quot; ]
do

if [ &quot;${Primes[i]}&quot; -eq &quot;$PRIME&quot; ]
# Don't bother sieving numbers already sieved (tagged as non-prime).
then

  t=$i

  while [ &quot;$t&quot; -le &quot;$UPPER_LIMIT&quot; ]
  do
    let &quot;t += $i &quot;
    Primes[t]=$NON_PRIME
    # Tag as non-prime all multiples.
  done

fi

  let &quot;i += 1&quot;
done


}


# ==============================================
# main ()
# Invoke the functions sequentially.
initialize
sift
print_primes
# This is what they call structured programming.
# ==============================================

echo

exit 0



# -------------------------------------------------------- #
# Code below line will not execute, because of 'exit.'

#  This improved version of the Sieve, by Stephane Chazelas,
#+ executes somewhat faster.

# Must invoke with command-line argument (limit of primes).

UPPER_LIMIT=$1                  # From command-line.
let SPLIT=UPPER_LIMIT/2         # Halfway to max number.

Primes=( '' $(seq $UPPER_LIMIT) )

i=1
until (( ( i += 1 ) &gt; SPLIT ))  # Need check only halfway.
do
  if [[ -n ${Primes[i]} ]]
  then
    t=$i
    until (( ( t += i ) &gt; UPPER_LIMIT ))
    do
      Primes[t]=
    done
  fi
done
echo ${Primes[*]}

exit $?
</pre>
<p><strong>Example 27-14. The Sieve of Eratosthenes, Optimized</strong></p>
<pre class="literal-block">
#!/bin/bash
# Optimized Sieve of Eratosthenes
# Script by Jared Martin, with very minor changes by ABS Guide author.
# Used in ABS Guide with permission (thanks!).

# Based on script in Advanced Bash Scripting Guide.
# http://tldp.org/LDP/abs/html/arrays.html#PRIMES0 (ex68.sh).

# http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf (reference)
# Check results against http://primes.utm.edu/lists/small/1000.txt

# Necessary but not sufficient would be, e.g.,
#     (($(sieve 7919 | wc -w) == 1000)) &amp;&amp; echo &quot;7919 is the 1000th prime&quot;

UPPER_LIMIT=${1:?&quot;Need an upper limit of primes to search.&quot;}

Primes=( '' $(seq ${UPPER_LIMIT}) )

typeset -i i t
Primes[i=1]='' # 1 is not a prime.
until (( ( i += 1 ) &gt; (${UPPER_LIMIT}/i) ))  # Need check only ith-way.
  do                                         # Why?
    if ((${Primes[t=i*(i-1), i]}))
    # Obscure, but instructive, use of arithmetic expansion in subscript.
    then
      until (( ( t += i ) &gt; ${UPPER_LIMIT} ))
        do Primes[t]=; done
    fi
  done

# echo ${Primes[*]}
echo   # Change to original script for pretty-printing (80-col. display).
printf &quot;%8d&quot; ${Primes[*]}
echo; echo

exit $?
</pre>
<p>Compare these array-based prime number generators with alternatives that
do not use arrays, <a class="reference external" href="contributed-scripts.html#PRIMES">Example A-15</a>,
and <a class="reference external" href="mathc.html#PRIMES2">Example 16-46</a>.</p>
<p>--</p>
<p>Arrays lend themselves, to some extent, to emulating data structures for
which Bash has no native support.</p>
<p><strong>Example 27-15. Emulating a push-down stack</strong></p>
<pre class="literal-block">
#!/bin/bash
# stack.sh: push-down stack simulation

#  Similar to the CPU stack, a push-down stack stores data items
#+ sequentially, but releases them in reverse order, last-in first-out.


BP=100            #  Base Pointer of stack array.
                  #  Begin at element 100.

SP=$BP            #  Stack Pointer.
                  #  Initialize it to &quot;base&quot; (bottom) of stack.

Data=             #  Contents of stack location.
                  #  Must use global variable,
                  #+ because of limitation on function return range.


                  # 100     Base pointer       &lt;-- Base Pointer
                  #  99     First data item
                  #  98     Second data item
                  # ...     More data
                  #         Last data item     &lt;-- Stack pointer


declare -a stack


push()            # Push item on stack.
{
if [ -z &quot;$1&quot; ]    # Nothing to push?
then
  return
fi

let &quot;SP -= 1&quot;     # Bump stack pointer.
stack[$SP]=$1

return
}

pop()                    # Pop item off stack.
{
Data=                    # Empty out data item.

if [ &quot;$SP&quot; -eq &quot;$BP&quot; ]   # Stack empty?
then
  return
fi                       #  This also keeps SP from getting past 100,
                         #+ i.e., prevents a runaway stack.

Data=${stack[$SP]}
let &quot;SP += 1&quot;            # Bump stack pointer.
return
}

status_report()          # Find out what's happening.
{
echo &quot;-------------------------------------&quot;
echo &quot;REPORT&quot;
echo &quot;Stack Pointer = $SP&quot;
echo &quot;Just popped \&quot;&quot;$Data&quot;\&quot; off the stack.&quot;
echo &quot;-------------------------------------&quot;
echo
}


# =======================================================
# Now, for some fun.

echo

# See if you can pop anything off empty stack.
pop
status_report

echo

push garbage
pop
status_report     # Garbage in, garbage out.

value1=23;        push $value1
value2=skidoo;    push $value2
value3=LAST;      push $value3

pop               # LAST
status_report
pop               # skidoo
status_report
pop               # 23
status_report     # Last-in, first-out!

#  Notice how the stack pointer decrements with each push,
#+ and increments with each pop.

echo

exit 0

# =======================================================


# Exercises:
# ---------

# 1)  Modify the &quot;push()&quot; function to permit pushing
#   + multiple element on the stack with a single function call.

# 2)  Modify the &quot;pop()&quot; function to permit popping
#   + multiple element from the stack with a single function call.

# 3)  Add error checking to the critical functions.
#     That is, return an error code, depending on
#   + successful or unsuccessful completion of the operation,
#   + and take appropriate action.

# 4)  Using this script as a starting point,
#   + write a stack-based 4-function calculator.
</pre>
<p>--</p>
<p>Fancy manipulation of array &quot;subscripts&quot; may require intermediate
variables. For projects involving this, again consider using a more
powerful programming language, such as Perl or C.</p>
<p><strong>Example 27-16. Complex array application: *Exploring a weird
mathematical series*</strong></p>
<pre class="literal-block">
#!/bin/bash

# Douglas Hofstadter's notorious &quot;Q-series&quot;:

# Q(1) = Q(2) = 1
# Q(n) = Q(n - Q(n-1)) + Q(n - Q(n-2)), for n&gt;2

#  This is a &quot;chaotic&quot; integer series with strange
#+ and unpredictable behavior.
#  The first 20 terms of the series are:
#  1 1 2 3 3 4 5 5 6 6 6 8 8 8 10 9 10 11 11 12

#  See Hofstadter's book, _Goedel, Escher, Bach: An Eternal Golden Braid_,
#+ p. 137, ff.


LIMIT=100     # Number of terms to calculate.
LINEWIDTH=20  # Number of terms printed per line.

Q[1]=1        # First two terms of series are 1.
Q[2]=1

echo
echo &quot;Q-series [$LIMIT terms]:&quot;
echo -n &quot;${Q[1]} &quot;             # Output first two terms.
echo -n &quot;${Q[2]} &quot;

for ((n=3; n &lt;= $LIMIT; n++))  # C-like loop expression.
do   # Q[n] = Q[n - Q[n-1]] + Q[n - Q[n-2]]  for n&gt;2
#    Need to break the expression into intermediate terms,
#+   since Bash doesn't handle complex array arithmetic very well.

  let &quot;n1 = $n - 1&quot;        # n-1
  let &quot;n2 = $n - 2&quot;        # n-2

  t0=`expr $n - ${Q[n1]}`  # n - Q[n-1]
  t1=`expr $n - ${Q[n2]}`  # n - Q[n-2]

  T0=${Q[t0]}              # Q[n - Q[n-1]]
  T1=${Q[t1]}              # Q[n - Q[n-2]]

Q[n]=`expr $T0 + $T1`      # Q[n - Q[n-1]] + Q[n - Q[n-2]]
echo -n &quot;${Q[n]} &quot;

if [ `expr $n % $LINEWIDTH` -eq 0 ]    # Format output.
then   #      ^ modulo
  echo # Break lines into neat chunks.
fi

done

echo

exit 0

#  This is an iterative implementation of the Q-series.
#  The more intuitive recursive implementation is left as an exercise.
#  Warning: calculating this series recursively takes a VERY long time
#+ via a script. C/C++ would be orders of magnitude faster.
</pre>
<p>--</p>
<p>Bash supports only one-dimensional arrays, though a little trickery
permits simulating multi-dimensional ones.</p>
<p><strong>Example 27-17. Simulating a two-dimensional array, then tilting it</strong></p>
<pre class="literal-block">
#!/bin/bash
# twodim.sh: Simulating a two-dimensional array.

# A one-dimensional array consists of a single row.
# A two-dimensional array stores rows sequentially.

Rows=5
Columns=5
# 5 X 5 Array.

declare -a alpha     # char alpha [Rows] [Columns];
                     # Unnecessary declaration. Why?

load_alpha ()
{
local rc=0
local index

for i in A B C D E F G H I J K L M N O P Q R S T U V W X Y
do     # Use different symbols if you like.
  local row=`expr $rc / $Columns`
  local column=`expr $rc % $Rows`
  let &quot;index = $row * $Rows + $column&quot;
  alpha[$index]=$i
# alpha[$row][$column]
  let &quot;rc += 1&quot;
done

#  Simpler would be
#+   declare -a alpha=( A B C D E F G H I J K L M N O P Q R S T U V W X Y )
#+ but this somehow lacks the &quot;flavor&quot; of a two-dimensional array.
}

print_alpha ()
{
local row=0
local index

echo

while [ &quot;$row&quot; -lt &quot;$Rows&quot; ]   #  Print out in &quot;row major&quot; order:
do                             #+ columns vary,
                               #+ while row (outer loop) remains the same.
  local column=0

  echo -n &quot;       &quot;            #  Lines up &quot;square&quot; array with rotated one.

  while [ &quot;$column&quot; -lt &quot;$Columns&quot; ]
  do
    let &quot;index = $row * $Rows + $column&quot;
    echo -n &quot;${alpha[index]} &quot;  # alpha[$row][$column]
    let &quot;column += 1&quot;
  done

  let &quot;row += 1&quot;
  echo

done

# The simpler equivalent is
#     echo ${alpha[*]} | xargs -n $Columns

echo
}

filter ()     # Filter out negative array indices.
{

echo -n &quot;  &quot;  # Provides the tilt.
              # Explain how.

if [[ &quot;$1&quot; -ge 0 &amp;&amp;  &quot;$1&quot; -lt &quot;$Rows&quot; &amp;&amp; &quot;$2&quot; -ge 0 &amp;&amp; &quot;$2&quot; -lt &quot;$Columns&quot; ]]
then
    let &quot;index = $1 * $Rows + $2&quot;
    # Now, print it rotated.
    echo -n &quot; ${alpha[index]}&quot;
    #           alpha[$row][$column]
fi

}




rotate ()  #  Rotate the array 45 degrees --
{          #+ &quot;balance&quot; it on its lower lefthand corner.
local row
local column

for (( row = Rows; row &gt; -Rows; row-- ))
  do       # Step through the array backwards. Why?

  for (( column = 0; column &lt; Columns; column++ ))
  do

    if [ &quot;$row&quot; -ge 0 ]
    then
      let &quot;t1 = $column - $row&quot;
      let &quot;t2 = $column&quot;
    else
      let &quot;t1 = $column&quot;
      let &quot;t2 = $column + $row&quot;
    fi

    filter $t1 $t2   # Filter out negative array indices.
                     # What happens if you don't do this?
  done

  echo; echo

done

#  Array rotation inspired by examples (pp. 143-146) in
#+ &quot;Advanced C Programming on the IBM PC,&quot; by Herbert Mayer
#+ (see bibliography).
#  This just goes to show that much of what can be done in C
#+ can also be done in shell scripting.

}


#--------------- Now, let the show begin. ------------#
load_alpha     # Load the array.
print_alpha    # Print it out.
rotate         # Rotate it 45 degrees counterclockwise.
#-----------------------------------------------------#

exit 0

# This is a rather contrived, not to mention inelegant simulation.

# Exercises:
# ---------
# 1)  Rewrite the array loading and printing functions
#     in a more intuitive and less kludgy fashion.
#
# 2)  Figure out how the array rotation functions work.
#     Hint: think about the implications of backwards-indexing an array.
#
# 3)  Rewrite this script to handle a non-square array,
#     such as a 6 X 4 one.
#     Try to minimize &quot;distortion&quot; when the array is rotated.
</pre>
<p>A two-dimensional array is essentially equivalent to a one-dimensional
one, but with additional addressing modes for referencing and
manipulating the individual elements by <em>row</em> and <em>column</em> position.</p>
<p>For an even more elaborate example of simulating a two-dimensional
array, see <a class="reference external" href="contributed-scripts.html#LIFESLOW">Example A-10</a>.</p>
<p>--</p>
<p>For more interesting scripts using arrays, see:</p>
<ul class="simple">
<li><a class="reference external" href="commandsub.html#AGRAM2">Example 12-3</a></li>
<li><a class="reference external" href="mathc.html#PRIMES2">Example 16-46</a></li>
<li><a class="reference external" href="contributed-scripts.html#HASHEX2">Example A-22</a></li>
<li><a class="reference external" href="contributed-scripts.html#HOMEWORK">Example A-44</a></li>
<li><a class="reference external" href="contributed-scripts.html#QKY">Example A-41</a></li>
<li><a class="reference external" href="contributed-scripts.html#NIM">Example A-42</a></li>
</ul>
<hr class="docutils" />
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="32%" />
<col width="31%" />
</colgroup>
<tbody valign="top">
<tr><td><a class="reference external" href="list-cons.html">Prev</a></td>
<td><a class="reference external" href="index.html">Home</a></td>
<td><a class="reference external" href="ivr.html">Next</a></td>
</tr>
<tr><td>List Constructs</td>
<td><a class="reference external" href="part5.html">Up</a></td>
<td>Indirect References</td>
</tr>
</tbody>
</table>
</div>
</div>
</body>
</html>
